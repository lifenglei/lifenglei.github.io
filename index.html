<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="前端开发沉淀">
<meta property="og:url" content="https://github.com/lifenglei/index.html">
<meta property="og:site_name" content="前端开发沉淀">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端开发沉淀">





  
  
  <link rel="canonical" href="https://github.com/lifenglei/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>前端开发沉淀</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">前端开发沉淀</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/21/ts章节之接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/21/ts章节之接口/" class="post-title-link" itemprop="url">ts章之接口</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-21 11:21:32 / Modified: 11:24:09" itemprop="dateCreated datePublished" datetime="2019-06-21T11:21:32+08:00">2019-06-21</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><pre><code>TypeScript的核心原则之一是对值所具有的结构进行类型检查，
它有时候被称作&quot;鸭式辨型法&quot;或&quot;结构性子类型化&quot;。在ts里，
接口的作用就是为这些类型命名和为你   得代码或第三方代码定义契约。
</code></pre><h4 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h4><h5 id="下面看一个例子来观察接口是如何工作的"><a href="#下面看一个例子来观察接口是如何工作的" class="headerlink" title="下面看一个例子来观察接口是如何工作的"></a>下面看一个例子来观察接口是如何工作的</h5><pre><code class="ts">    function printLabel(labelledObj: { label: string }) {
      console.log(labelledObj.label);
    }

    let myObj = { size: 10, label: &quot;Size 10 Object&quot; };
    printLabel(myObj);
</code></pre>
<h5 id="类型检查器会查看printLable的调用，它有一个参数，并要求这个对象参数有一个名为label类型为string的属性，需要注意的是，我们传入的对象参数实际上包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配"><a href="#类型检查器会查看printLable的调用，它有一个参数，并要求这个对象参数有一个名为label类型为string的属性，需要注意的是，我们传入的对象参数实际上包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配" class="headerlink" title="类型检查器会查看printLable的调用，它有一个参数，并要求这个对象参数有一个名为label类型为string的属性，需要注意的是，我们传入的对象参数实际上包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配"></a>类型检查器会查看<font color="red">printLable</font>的调用，它有一个参数，并要求这个对象参数有一个名为<font color="red">label</font>类型为<font color="red">string</font>的属性，需要注意的是，我们传入的对象参数实际上包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配</h5><h5 id="下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string："><a href="#下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：" class="headerlink" title="下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string："></a>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</h5><pre><code class="ts">    interface LabelledValue {
        label: string;
    }

    function printLabel(labelledObj: LabelledValue) {
      console.log(labelledObj.label);
    }

    let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
    printLabel(myObj);
</code></pre>
<h5 id="LabelledValue接口就好比一个名字，用来描述上面例子里的要求。-它代表了有一个-label属性且类型为string的对象"><a href="#LabelledValue接口就好比一个名字，用来描述上面例子里的要求。-它代表了有一个-label属性且类型为string的对象" class="headerlink" title="LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象"></a><font color="red">LabelledValue</font>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <font color="red">label</font>属性且类型为<font color="red">string</font>的对象</h5><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><h5 id="接口里的属性不全都是必需的。-有些是只在某些条件下存在，或者根本不存在。-可选属性在应用“option-bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。"><a href="#接口里的属性不全都是必需的。-有些是只在某些条件下存在，或者根本不存在。-可选属性在应用“option-bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。" class="headerlink" title="接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。"></a>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</h5><pre><code class="ts">    interface SquareConfig {
      color?: string;
      width?: number;
    }

    function createSquare(config: SquareConfig): {color: string; area: number} {
      let newSquare = {color: &quot;white&quot;, area: 100};
      if (config.color) {
        newSquare.color = config.color;
      }
      if (config.width) {
        newSquare.area = config.width * config.width;
      }
      return newSquare;
    }

    let mySquare = createSquare({color: &quot;black&quot;});    
</code></pre>
<h6 id="带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个-符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。-比如，我们故意将-createSquare里的color属性名拼错，就会得到一个错误提示："><a href="#带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个-符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。-比如，我们故意将-createSquare里的color属性名拼错，就会得到一个错误提示：" class="headerlink" title="带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示："></a>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<font color="red">?</font>符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</h6><pre><code class="ts">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.clor) {
    // Error: Property &#39;clor&#39; does not exist on type &#39;SquareConfig&#39;
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><h5 id="接口能够描述JavaScript中对象拥有的各种各样的外形。-除了描述带有属性的普通对象外，接口也可以描述函数类型。"><a href="#接口能够描述JavaScript中对象拥有的各种各样的外形。-除了描述带有属性的普通对象外，接口也可以描述函数类型。" class="headerlink" title="接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。"></a>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</h5><h5 id="为了使用接口表示函数类型，我们需要给接口定义一个调用签名。-它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。"><a href="#为了使用接口表示函数类型，我们需要给接口定义一个调用签名。-它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。" class="headerlink" title="为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。"></a>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</h5><pre><code class="ts">    interface SearchFunc {
        (source: string, subString: string):boolean;
    }
</code></pre>
<h5 id="这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。-下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。"><a href="#这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。-下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。" class="headerlink" title="这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。"></a>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</h5><pre><code class="ts">    let mySearch: SearchFunc;
    mySearch = function(source: string, subString: string) {
      let result = source.search(subString);
      return result &gt; -1;
    }
</code></pre>
<h5 id="对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。-比如，我们使用下面的代码重写上面的例子："><a href="#对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。-比如，我们使用下面的代码重写上面的例子：" class="headerlink" title="对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子："></a>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</h5><pre><code>    let mySearch: SearchFunc;
    mySearch = function(src: string, sub: string): boolean {
      let result = src.search(sub);
      return result &gt; -1;
    }

</code></pre><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><h5 id="一个接口可以继承多个接口，创建出多个接口的合成接口。"><a href="#一个接口可以继承多个接口，创建出多个接口的合成接口。" class="headerlink" title="一个接口可以继承多个接口，创建出多个接口的合成接口。"></a>一个接口可以继承多个接口，创建出多个接口的合成接口。</h5><pre><code>    interface Shape {
        color: string;
    }

    interface PenStroke {
        penWidth: number;
    }

    interface Square extends Shape, PenStroke {
        sideLength: number;
    }

    let square = &lt;Square&gt;{};
    square.color = &quot;blue&quot;;
    square.sideLength = 10;
    square.penWidth = 5.0;
</code></pre><h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><h5 id="接口能够描述JavaScript里丰富的类型。-因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。"><a href="#接口能够描述JavaScript里丰富的类型。-因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。" class="headerlink" title="接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。"></a>接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</h5><pre><code>    interface Counter {
        (start: number): string;
        interval: number;
        reset(): void;
    }

    function getCounter(): Counter {
        let counter = &lt;Counter&gt;function (start: number) { };
        counter.interval = 123;
        counter.reset = function () { };
        return counter;
    }

    let c = getCounter();
    c(10);
    c.reset();
    c.interval = 5.0;
</code></pre><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><h5 id="当接口继承了一个类类型时，它会继承类的成员但不包括其实现。-就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。-接口同样会继承到类的private和protected成员。-这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。-这个子类除了继承至基类外与基类没有任何关系。-例："><a href="#当接口继承了一个类类型时，它会继承类的成员但不包括其实现。-就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。-接口同样会继承到类的private和protected成员。-这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。-这个子类除了继承至基类外与基类没有任何关系。-例：" class="headerlink" title="当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例："></a>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</h5><pre><code>    class Control {
        private state: any;
    }

    interface SelectableControl extends Control {
        select(): void;
    }

    class Button extends Control implements SelectableControl {
        select() { }
    }

    class TextBox extends Control {
        select() { }
    }

    // 错误：“Image”类型缺少“state”属性。
    class Image implements SelectableControl {
        select() { }
    }

    class Location {

    }
</code></pre><h6 id="在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。-因为-state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。-因为只有-Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。-实际上，-SelectableControl接口和拥有select方法的Control类是一样的。-Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。"><a href="#在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。-因为-state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。-因为只有-Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。-实际上，-SelectableControl接口和拥有select方法的Control类是一样的。-Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。" class="headerlink" title="在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。"></a>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</h6><hr>
<h4 id="附上我在学习接口时候的代码"><a href="#附上我在学习接口时候的代码" class="headerlink" title="附上我在学习接口时候的代码"></a>附上我在学习接口时候的代码</h4><pre><code>    //面向对象----接口
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);

//规范函数接口
interface  SearchMan{
  (source:string,subString:string):boolean
}

let mySearch:SearchMan

mySearch = function(source:string,subString:string):boolean{
  console.log(source)
  console.log(subString)
  let flag =source.search(subString)
  return (flag != -1)
} 

console.log(mySearch(&#39;高、富、帅、德&#39;,&#39;高&#39;)) //false

interface SquareConfig{
  color?:string;
  width?:number;
  [propName:string]:any;
}
function createSquare(config:SquareConfig):{color:string;area:number}{
  let newSquare = {
    color:&#39;white&#39;,
    area:100
  }
  if(config.color){
    newSquare.color=config.color
  }
  if(config.width){
    newSquare.area = config.width*config.width
  }
  return newSquare

}
let mySquare = createSquare({color:&#39;black&#39;,width:100});
//类型接口
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = &lt;Counter&gt;function (start: number) { };
  counter.interval = 123;
  counter.reset = function () { };
  return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre><h3 id="下一节-ts中的函数"><a href="#下一节-ts中的函数" class="headerlink" title="^^下一节 ts中的函数"></a>^^下一节 ts中的函数</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/20/ts章之基础类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/20/ts章之基础类型/" class="post-title-link" itemprop="url">ts章之基础类型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-20 11:54:41 / Modified: 12:07:14" itemprop="dateCreated datePublished" datetime="2019-06-20T11:54:41+08:00">2019-06-20</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。-TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。"><a href="#为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。-TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。" class="headerlink" title="为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。"></a>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</h5><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><pre><code>let isDuan: boolean = false
</code></pre><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><h5 id="和javascript一样，ts里的所有数字都是浮点数，这些浮点数的类型是number。除了支持十进制和十六进制字面量，ts还支持es5中引入的二进制和八进制字面量。"><a href="#和javascript一样，ts里的所有数字都是浮点数，这些浮点数的类型是number。除了支持十进制和十六进制字面量，ts还支持es5中引入的二进制和八进制字面量。" class="headerlink" title="和javascript一样，ts里的所有数字都是浮点数，这些浮点数的类型是number。除了支持十进制和十六进制字面量，ts还支持es5中引入的二进制和八进制字面量。"></a>和javascript一样，ts里的所有数字都是浮点数，这些浮点数的类型是<font style="color:red">number</font>。除了支持十进制和十六进制字面量，ts还支持es5中引入的二进制和八进制字面量。</h5><pre><code>let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="普通字符串"><a href="#普通字符串" class="headerlink" title="普通字符串"></a>普通字符串</h5><pre><code>let name:string = &quot;duanduan&quot;
name = &quot;lei&quot;
</code></pre><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><pre><code>let name: string = &quot;duanduan&quot;
let age: number = 29;
let sentence: string = `Hello,my name is ${name}.I will be ${age+1} years old next month`
</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>可以在元素类型后面接上<font style="color:red">[]</font>,表示由此类型元素组成的U一个数组<pre><code class="js">let list: number[] = [1,2,3];
</code></pre>
</li>
<li>数组泛型，<font style="color:red">Array&lt;元素类型&gt;</font><pre><code class="js">let list: Array&lt;number&gt; = [1,2,3]
</code></pre>
<h4 id="元祖类型-Tuple"><a href="#元祖类型-Tuple" class="headerlink" title="元祖类型 Tuple"></a>元祖类型 Tuple</h4><h5 id="元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。-比如，你可以定义一对值分别为-string和number类型的元组。"><a href="#元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。-比如，你可以定义一对值分别为-string和number类型的元组。" class="headerlink" title="元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。"></a>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <font style="color:red">string和number</font>类型的元组。</h5><pre><code class="ts">//declare a tuple type
let x: [string,number];
//Initialize it 
x = [&#39;duanduan&#39;,29] // ok
//Initialize it incorrectly
x = [10,&#39;duanduan&#39;] // Error
</code></pre>
<h5 id="当访问一个已知索引的元素-会得到正确的类型"><a href="#当访问一个已知索引的元素-会得到正确的类型" class="headerlink" title="当访问一个已知索引的元素 会得到正确的类型"></a>当访问一个已知索引的元素 会得到正确的类型</h5><pre><code class="ts">console.log(x[0].substr(1)) //ok
console.log(x[1].substr(1))// &#39;number&#39; does not have &#39;substr&#39;
</code></pre>
</li>
</ul>
<p>当访问一个越界的元素 会使用联合类型替代</p>
<pre><code>x[3] = &#39;world&#39;; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()); // OK, &#39;string&#39; 和 &#39;number&#39; 都有 toString

x[6] = true; // Error, 布尔不是(string | number)类型
</code></pre><h4 id="联合类型是高级主题，我们会在以后的章节里讨论它。"><a href="#联合类型是高级主题，我们会在以后的章节里讨论它。" class="headerlink" title="联合类型是高级主题，我们会在以后的章节里讨论它。"></a>联合类型是高级主题，我们会在以后的章节里讨论它。</h4><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><font style="color:red">enum</font>类型是对JavaScript标准数据类型的一个补充。</p>
<pre><code class="ts">    enum Info {name=&#39;duanduan&#39;,website=&#39;blog&#39;,age=29}
    let n: Info = Info.name
</code></pre>
<h5 id="枚举类型提供的一个便利是你可以由枚举的值得到它的名字。-例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字："><a href="#枚举类型提供的一个便利是你可以由枚举的值得到它的名字。-例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：" class="headerlink" title="枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字："></a>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</h5><pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName);  // 显示&#39;Green&#39;因为上面代码里它的值是2
</code></pre><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><h5 id="有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。-这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。-这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。-那么我们可以使用-any类型来标记这些变量："><a href="#有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。-这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。-这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。-那么我们可以使用-any类型来标记这些变量：" class="headerlink" title="有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量："></a>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</h5><pre><code>let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre><h5 id="当你只知道一部分数据的类型时，any类型也是有用的。-比如，你有一个数组，它包含了不同的类型的数据："><a href="#当你只知道一部分数据的类型时，any类型也是有用的。-比如，你有一个数组，它包含了不同的类型的数据：" class="headerlink" title="当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据："></a>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</h5><pre><code>let list: any[] = [1, true, &quot;free&quot;];
list[1] = 100;
</code></pre><h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><h4 id="某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。-当一个函数没有返回值时，你通常会见到其返回值类型是-void："><a href="#某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。-当一个函数没有返回值时，你通常会见到其返回值类型是-void：" class="headerlink" title="某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void："></a>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</h4><pre><code>function warnUser(): void {
    console.log(&quot;This is my warning message&quot;);
}
</code></pre><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><h5 id="TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。-和-void相似，它们的本身的类型用处不是很大："><a href="#TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。-和-void相似，它们的本身的类型用处不是很大：" class="headerlink" title="TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大："></a>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</h5><pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><h5 id="默认情况下null和undefined是所有类型的子类型。-就是说你可以把-null和undefined赋值给number类型的变量。"><a href="#默认情况下null和undefined是所有类型的子类型。-就是说你可以把-null和undefined赋值给number类型的变量。" class="headerlink" title="默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。"></a>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</h5><h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><h5 id="never类型表示的是那些永不存在的值的类型"><a href="#never类型表示的是那些永不存在的值的类型" class="headerlink" title="never类型表示的是那些永不存在的值的类型"></a><font style="color:red">never</font>类型表示的是那些永不存在的值的类型</h5><pre><code>// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。"><a href="#object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。" class="headerlink" title="object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。"></a>object表示非原始类型，也就是除<font style="color:red">number，string，boolean，symbol，null或undefined</font>之外的类型。</h5><h5 id="使用object类型，就可以更好的表示像Object-create这样的API。例如："><a href="#使用object类型，就可以更好的表示像Object-create这样的API。例如：" class="headerlink" title="使用object类型，就可以更好的表示像Object.create这样的API。例如："></a>使用object类型，就可以更好的表示像Object.create这样的API。例如：</h5><pre><code>declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create(&quot;string&quot;); // Error
create(false); // Error
create(undefined); // Error
</code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul>
<li>尖括号<pre><code class="js">    let someValue: any = &quot;this is a string&quot;;
    let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
</li>
<li><p><font style="color:red">as</font>语法</p>
<pre><code class="js">    let someValue: any = &quot;this is a string&quot;;
    let strLength: number = (someValue as string).length;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="TypeScript中的数据类型有："><a href="#TypeScript中的数据类型有：" class="headerlink" title="TypeScript中的数据类型有："></a>TypeScript中的数据类型有：</h4><p>Undefined :<br>Number:数值类型;<br>string : 字符串类型;<br>Boolean: 布尔类型；<br>enum：枚举类型；<br>any : 任意类型，一个牛X的类型；<br>void：空类型；<br>Array : 数组类型;<br>Tuple : 元祖类型；<br>Null ：空类型</p>
<h4 id="附上我在学习ts的时候写的测试代码"><a href="#附上我在学习ts的时候写的测试代码" class="headerlink" title="附上我在学习ts的时候写的测试代码"></a>附上我在学习ts的时候写的测试代码</h4><pre><code class="ts">//数组声明
let arr1:number[] //声明数值类型的数组
let arr2:Array&lt;string&gt;//声明字符串类型的数组

//字面量赋值
let arr3:number[] = []
let arr4:number[] = [1,2,3,4]
let arr5:Array&lt;string&gt;=[&#39;1&#39;,&#39;3&#39;,&#39;6&#39;]
let someValue:string=&#39;this is a boy&#39;
let strLength:number = (&lt;string&gt;someValue).length
//  console.log(strLength)
let arr6:Array&lt;boolean&gt;=[true,false,true]
//元祖类型
let x:[string,number]
x=[&#39;1&#39;,2]
//引用类型字符串
let like:String = new String(&#39;code&#39;)
//  console.log(like)
//引用类型日期对象
let d:Date = new Date()
//传递一个整数
let da:Date = new Date(1000)
console.log(da)
//传递一个字符串
//yyyy/MM/dd hh:mm:ss，yyyy-MM-dd hh:mm:ss，yyyy-MM-ddThh:mm:ss
let dt:Date = new Date(&#39;2018/09/06 05:30:00&#39;)
// console.log(dt)
//正则表达式

let reg1:RegExp = new RegExp(&#39;code&#39;)
let reg2:RegExp = new RegExp(&#39;code&#39;,&#39;gi&#39;)
let reg3:RegExp = /code/
let reg4:RegExp = /code/gi
let site:string = &#39;codeview.com&#39;
let isT:boolean = reg3.test(site)
// console.log(isT)
console.log(reg4.exec(site))
</code></pre>
<h3 id="下一节-ts章之接口"><a href="#下一节-ts章之接口" class="headerlink" title="^^下一节 ts章之接口"></a>^^下一节 ts章之接口</h3></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/canvas海报/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/canvas海报/" class="post-title-link" itemprop="url">canvas海报</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:28:35 / Modified: 15:28:43" itemprop="dateCreated datePublished" datetime="2019-06-19T15:28:35+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分享到朋友圈海报生成实现"><a href="#分享到朋友圈海报生成实现" class="headerlink" title="分享到朋友圈海报生成实现"></a>分享到朋友圈海报生成实现</h2><h4 id="临时接到一个需求需要实现一个分享到朋友圈的功能-用户点击分享到朋友圈按钮后要生成海报图-方便用户保存分享-刚接到这个需求的时候是一脸懵逼-接着是三脸懵逼-在技术群里咨询-然而并没有找到答案-思考一番后我决定使用canvas去实现-然而我认识canvas-canvas却不认识我-只好当天晚上看canvas的api-隔天完成了这个需求-下面分享下绘制的过程-也是自己的一个总结"><a href="#临时接到一个需求需要实现一个分享到朋友圈的功能-用户点击分享到朋友圈按钮后要生成海报图-方便用户保存分享-刚接到这个需求的时候是一脸懵逼-接着是三脸懵逼-在技术群里咨询-然而并没有找到答案-思考一番后我决定使用canvas去实现-然而我认识canvas-canvas却不认识我-只好当天晚上看canvas的api-隔天完成了这个需求-下面分享下绘制的过程-也是自己的一个总结" class="headerlink" title="临时接到一个需求需要实现一个分享到朋友圈的功能 用户点击分享到朋友圈按钮后要生成海报图 方便用户保存分享 刚接到这个需求的时候是一脸懵逼 接着是三脸懵逼 在技术群里咨询 然而并没有找到答案 思考一番后我决定使用canvas去实现 然而我认识canvas  canvas却不认识我 只好当天晚上看canvas的api  隔天完成了这个需求 下面分享下绘制的过程 也是自己的一个总结"></a>临时接到一个需求需要实现一个分享到朋友圈的功能 用户点击分享到朋友圈按钮后要生成海报图 方便用户保存分享 刚接到这个需求的时候是一脸懵逼 接着是三脸懵逼 在技术群里咨询 然而并没有找到答案 思考一番后我决定使用canvas去实现 然而我认识canvas  canvas却不认识我 只好当天晚上看canvas的api  隔天完成了这个需求 下面分享下绘制的过程 也是自己的一个总结</h4><h3 id="一：canvas有哪些功能"><a href="#一：canvas有哪些功能" class="headerlink" title="一：canvas有哪些功能"></a>一：canvas有哪些功能</h3><pre><code>1.绘制图形
2.绘制图像
3.绘制文字
</code></pre><h3 id="二：canvas的绘制步骤"><a href="#二：canvas的绘制步骤" class="headerlink" title="二：canvas的绘制步骤"></a>二：canvas的绘制步骤</h3><p>canvas就是画图 那么到底该怎么画图呢 首先大家要明白canvas 2D环境坐标系 下面以一张简单的图来说明一下(注：该图来自为w3cPlus)<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1703/canvas-2-4.png" alt><br>相信学过坐标系系统的同学都能明白这张图的意思 其实canvas就是在正确的位置用正确的api绘制出自己想要的图 正确的位置就是需要坐标来体现的</p>
<h4 id="设计稿呈现"><a href="#设计稿呈现" class="headerlink" title="设计稿呈现"></a>设计稿呈现</h4><p><img src="http://pic5.40017.cn/02/001/b0/90/rBLkCVuCX8yAJuFyAADZncnHWh0076.jpg" alt="设计稿"></p>
<h4 id="代码部分-要想学好canvas对着代码看一句-然后就翻看canvas的api"><a href="#代码部分-要想学好canvas对着代码看一句-然后就翻看canvas的api" class="headerlink" title="代码部分 要想学好canvas对着代码看一句 然后就翻看canvas的api"></a>代码部分 要想学好canvas对着代码看一句 然后就翻看canvas的api</h4><pre><code class="javascript">      import wepy from &#39;wepy&#39;
  let app = getApp()
  export default class tczan extends wepy.component {
    props = {
      ob:{
        type:Object,
        default:{
                   //头像路径
        }
      }
    }
    methods = {
      saveImageToPhotosAlbum(){
        this.savePhoto()
      }
    }
    //文字换行
    canvasWrapText(text,cs,x, y, maxWidth, lineHeight){
        // 字符分隔为数组
        var arrText = text.split(&#39;&#39;);
        var line = &#39;&#39;;
        for (var n = 0; n &lt; arrText.length; n++) {
            var testLine = line + arrText[n];
            var metrics = cs.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) {
                cs.fillText(line, x, y);
                line = arrText[n];
                y += lineHeight;
            } else {
                line = testLine;
            }
        }
        cs.fillText(line, x, y);
    }
    onLoad(options){
        wx.downloadFile({
          url:  this.ob.avatarUrl
        })
        this.imageToPhotosAlbum()
    }
    savePhoto(){
         wx.showLoading({
          title:&#39;保存中...&#39;
        })
        var that = this;
        var unit = that.ob.screenWidth/375
        wx.canvasToTempFilePath({
              x: 0,
              y: 0,
              width: unit * 375,
              height: unit * 462.5,
              destWidth: unit * 375,
              destHeight: unit * 462.5,
              canvasId: &#39;share&#39;,
              success: function (res) {
                that.ob.shareImgPath=res.tempFilePath
                  if (!res.tempFilePath) {
                      wx.showModal({
                          title: &#39;提示&#39;,
                          content: &#39;图片绘制中，请稍后重试&#39;,
                          showCancel: false
                      })
                  }
                  //画板路径保存成功后，调用方法吧图片保存到用户相册
                  wx.saveImageToPhotosAlbum({
                      filePath: res.tempFilePath,
                      //保存成功失败之后，都要隐藏画板，否则影响界面显示。
                      success: (res) =&gt; {
                         wx.showToast({
                              title: &#39;保存完成&#39;,  //标题
                              icon: &#39;success&#39;,  //图标，支持&quot;success&quot;、&quot;loading&quot;
                              duration: 2000 //提示的延迟时间，单位毫秒，默认：1500
                          })
                          that.ob.canvasHidden=true
                      },
                      fail: (err) =&gt; {
                          wx.showToast({
                              title: &#39;保存失败&#39;,  //标题
                              icon: &#39;&#39;,  //图标，支持&quot;success&quot;、&quot;loading&quot;
                              duration: 2000, //提示的延迟时间，单位毫秒，默认：1500
                              mask: false  //是否显示透明蒙层，防止触摸穿透，默认：false
                          })
                          that.ob.canvasHidden=true
                      }
                  })
              }
          })
    }
    imageToPhotosAlbum(){
        wx.showLoading({
          title:&#39;生成中...&#39;
        })
        var that = this;
        that.canvasHidden = false
        var unit = that.ob.screenWidth/375
        var {avatarurl,cover,nickName,type,poi,description,title}=that.ob
        var context = wx.createCanvasContext(&#39;share&#39;)
      var description = that.ob.description
      var wxappName = &quot;打开小程序马上浏览&quot;
      var gradient = context.createLinearGradient(0, 0, unit * 50, 0); 
      //绘制渐变部分
      gradient.addColorStop(0,&quot;#F3EED1&quot;);
      gradient.addColorStop(1,&quot;#EDE5B7&quot;);
      context.fillStyle=gradient;
      context.fillRect(-unit*20,unit*10,unit *85,unit *50);
      var gradients = context.createLinearGradient(0, 0, unit * 50, 0); 
      //绘制渐变部分
      gradients.addColorStop(0,&quot;#F3EED1&quot;);
      gradients.addColorStop(1,&quot;#fff&quot;);
      context.fillStyle=gradients;
      context.fillRect(-unit*40,unit*90,unit *100,unit *50);
      context.drawImage(`${cover}`, unit * 140, unit * 455, unit * 64, unit * 64)
      context.drawImage(`${cover}`, unit * 40, unit * 175, unit * 255, unit * 150)
      //绘制文本
      context.font=&quot;bold 12px PingFangSC-Medium&quot;;
      context.setFillStyle(&#39;#666&#39;)
      context.fillText(`${nickName}`, unit * 90, unit * 30)  //绘制文字
      context.font=&quot;12px PingFangSC-Light&quot;;
      context.setFillStyle(&#39;#999&#39;)
      context.fillText(`推荐了1篇${type}`, unit * 90, unit * 53)  //绘制文字
      context.fillText(`${poi}`, unit * 40, unit * 160)  //绘制文字
      context.fillText(wxappName, unit * 115, unit * 580)
      context.setFontSize(14)
      context.setFillStyle(&quot;#999&quot;)
      context.fillText(&quot;长按识别小程序&quot;, unit * 115, unit * 560)  //绘制文字
      that.canvasWrapText(`${description}`,context, unit * 40, unit * 355,unit * 255,unit * 24)
      context.font=&quot;24px PingFangSC-Medium&quot;;
      context.setFillStyle(&#39;#444&#39;)
      that.canvasWrapText(`${title}`,context, unit * 40, unit * 129,unit * 225,unit * 24)
      //圆形裁剪填充头像
      context.save()
      context.beginPath()
      context.lineWidth = unit *8;
      context.strokeStyle = &quot;#fff&quot;;//线条的颜色
      context.lineCap = &quot;round&quot;;
      context.arc(unit * 59, unit * 36, unit *22, 0, 2 * Math.PI,true)  
      context.stroke();
      context.closePath();
      context.clip() 
      context.drawImage(`${cover}`, unit * 33, unit *10, unit * 50, unit * 50)  
      context.restore()
      wx.hideLoading()
      context.draw(false, function () {
      });
    }
  }
</code></pre>
<h4 id="设计稿还原-（部分字段没有-设计变更-图中不展示）"><a href="#设计稿还原-（部分字段没有-设计变更-图中不展示）" class="headerlink" title="设计稿还原 （部分字段没有 设计变更 图中不展示）"></a>设计稿还原 （部分字段没有 设计变更 图中不展示）</h4><p> <img src="http://pic5.40017.cn/01/001/b0/8a/rBLkBluCYJSAZfuyAADapaVzAvQ829.jpg" alt></p>
<h4 id="还原能力有限-目前还在进行细节调整-但是已经具备雏形-从懵逼到理解-到完成需求-我觉得也是一种进步吧"><a href="#还原能力有限-目前还在进行细节调整-但是已经具备雏形-从懵逼到理解-到完成需求-我觉得也是一种进步吧" class="headerlink" title="还原能力有限 目前还在进行细节调整 但是已经具备雏形 从懵逼到理解 到完成需求 我觉得也是一种进步吧"></a>还原能力有限 目前还在进行细节调整 但是已经具备雏形 从懵逼到理解 到完成需求 我觉得也是一种进步吧</h4><h4 id="canvas的api很多-重在理解和自己动手操作-可以看看w3c上的教程"><a href="#canvas的api很多-重在理解和自己动手操作-可以看看w3c上的教程" class="headerlink" title="canvas的api很多 重在理解和自己动手操作 可以看看w3c上的教程"></a>canvas的api很多 重在理解和自己动手操作 可以看看w3c上的教程</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/vueConf总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/vueConf总结/" class="post-title-link" itemprop="url">vueConf总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:23:26 / Modified: 15:23:43" itemprop="dateCreated datePublished" datetime="2019-06-19T15:23:26+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vueConf-2019-尤雨溪演讲总结"><a href="#vueConf-2019-尤雨溪演讲总结" class="headerlink" title="vueConf 2019 尤雨溪演讲总结"></a>vueConf 2019 尤雨溪演讲总结</h3><blockquote>
<p>距离参加 VueConf第一届大会已经很久了，yubo的介绍一如既往的有意思❤️，<br>是他的努力保持了大会热情的社区氛围！另一个彩蛋就是Evan You 带了自己的亲人和孩子来到现场，真的是其乐融融！</p>
</blockquote>
<h4 id="尤雨溪-State-of-vue"><a href="#尤雨溪-State-of-vue" class="headerlink" title="尤雨溪@State of vue"></a>尤雨溪@State of vue</h4><p><img src="https://static.soyoung.com/sy-pre/WX20190609-101450@2x-1560046205424.png" alt="imgConf" title="演讲图片"></p>
<h3 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h3><p>#####<br>Chrome DevTools 有约 90 万的周活用户，React 相比有 160 万。Evan 推荐用 Chrome DevTools 来预测 Vue 的项目的真实开发者数据。Vue 有全球化的影响力，在非常多的国家有相应的活动，可以 通过<a href="https://events.vuejs.org/" target="_blank"> events.vuejs.org</a> 查找。State of JavaScript 2018 年统计说明在前端框架的满意度是第一名（91%），并在 Stack Overflow 的数据里体现是第二受欢迎的前端框架。</p>
<h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>####<br>现在 Vue 有 20 人活跃的开发者，大部分日常工作与Vue 相关，完全独立运营，而成本主要来自于赞助商，年来稳步增长。蒋豪群（@sodatea）全职在维护CLI及相关工具链。</p>
<h3 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h3><p><img src="https://static.soyoung.com/sy-pre/WX20190609-102403@2x-1560046205424.png" alt="imgConf" title="进展"></p>
<p>####<br>自 2018 年年底有过预告 Vue.js 3.0 的设定目标，其实在今年年初的时候大部分功能已经实现。但同时，在开发的同是也在研究业界最新的方案，Vue 在 3.0 使用了 Proxy 的功能，但是 IE 11 仍然无法支持却有一定市场占有率。</p>
<h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><p><img src="https://static.soyoung.com/sy-pre/WX20190609-102631@2x-1560046205424.png" alt="imgConf" title="更快"></p>
<p>#####<br>1.<font style="color:red">Object.defineProperty -&gt; Proxy：Proxy </font>不需要对原始对象做太多改动，效率更高</p>
<p>2.Virtual DOM 重构：组建的启动速度等比 2.5 快了一倍，生成 VNode 参数一致化。但是还是可以做的更好，Virtual DOM 的目的并非只是速度，其核心价值在于用 JavaScript 表达 DOM 状态，因此它本身其实是有成本的。即每次更新时， vdom 树需要每次都重新建立，因此传统的 vdom 是有性能瓶颈。而这背后的原因是 vdom 最早是由 JSX 写的表达逻辑（灵活性），而非是模版语言，因此不能通过模版内容推测一些信息。<br><img src="https://static.soyoung.com/sy-pre/WX20190609-103238@2x-1560046205424.png" alt="lifenglei" title="vdom"></p>
<p><img src="https://static.soyoung.com/sy-pre/WX20190609-103254@2x-1560046205424.png" alt><br>3.如何最大化的动静结合？即兼容 render function 的灵活性，及模版表达的信息<br><img src="https://static.soyoung.com/sy-pre/WX20190609-103314@2x-1560046205424.png" alt><br>将一个逻辑内部、外部的节点分开，每个动态节点当成一个 (fragment) 这使得动态节点别话只会出现在如 v-if、v-for 这样的结构性指令之下。将节点关系切分为一个一个的区块树（Block Tree，梗😊），减少无谓的遍历。</p>
<p>这使得vdom 的更新性能与模版大小相关 =&gt; 与动态内容的数量相关（即哪儿需要改，就只让哪儿改，只实现最小操作）<br><img src="https://static.soyoung.com/sy-pre/WX20190609-104007@2x-1560046205424.png" alt><br>速度优化：2.6.10（36ms），3.0（5.44ms）约 6 倍的速度增长</p>
<h5 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h5><ul>
<li>Class API ❌：<ul>
<li>原本的目的是支持 TypeScript：this 下的属性类型推到无法有效实现，Decorator 提案很不稳定</li>
<li>Class API 除了使用了原生愈发，并未带来任何新的优势，OOP 里的继承等价值在 UI 层使用较少</li>
</ul>
</li>
<li>Function-based API ✅：<ul>
<li><img src="https://static.soyoung.com/sy-pre/WX20190609-104845@2x-1560046205424.png" alt></li>
<li><img src="https://static.soyoung.com/sy-pre/WX20190609-105018@2x-1560046205424.png" alt></li>
<li>更好的 TypeScript 类型推导支持（不需要任何手动的类型声明，一套代码同时支持），更灵活的逻辑复用（没有命名冲突、props 等数据来源更清晰、没有额外的创建成本），Tree-shaking 友好，代码可以被压缩<h4 id="逻辑复用案例：鼠标位置监听"><a href="#逻辑复用案例：鼠标位置监听" class="headerlink" title="逻辑复用案例：鼠标位置监听"></a>逻辑复用案例：鼠标位置监听</h4><img src="https://static.soyoung.com/sy-pre/WX20190609-105202@2x-1560046205424.png" alt><h4 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h4></li>
</ul>
</li>
<li>当大量使用时候<ul>
<li>❌ 命名空间冲突</li>
<li>❌   模板数据来源不清晰<h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4></li>
</ul>
</li>
<li><img src="https://static.soyoung.com/sy-pre/WX20190609-105617@2x-1560046205424.png" alt></li>
<li>当高阶组件大量使用时候<ul>
<li>❌  props命名空间冲突 </li>
<li>❌   props来源不清晰 </li>
<li>❌   额外的组件实例性能消耗</li>
</ul>
</li>
</ul>
<h4 id="Renderless-Components-作用域插槽"><a href="#Renderless-Components-作用域插槽" class="headerlink" title="Renderless Components 作用域插槽"></a>Renderless Components 作用域插槽</h4><p><img src="https://static.soyoung.com/sy-pre/WX20190609-110404@2x-1560046205424.png" alt></p>
<ul>
<li>当使用作用域插槽时候<ul>
<li>✅  没有命名空间冲突</li>
<li>✅  数据来源清晰</li>
<li>❌   额外的组件实例性能消耗<h4 id="with-New-API"><a href="#with-New-API" class="headerlink" title="with New API"></a>with New API</h4><img src="https://static.soyoung.com/sy-pre/WX20190609-110823@2x-1560046205424.png" alt><br><img src="https://static.soyoung.com/sy-pre/WX20190609-110840@2x-1560046205424.png" alt></li>
</ul>
</li>
<li>当使用新的api时候<ul>
<li>✅ 没有命名空间冲突</li>
<li>✅  数据来源清晰</li>
<li>✅   没有额外的组件实例性能消耗</li>
<li>对比React Hooks<ul>
<li>同样的逻辑组合、复用能力</li>
<li>只调用一次<ul>
<li>符合js直觉</li>
<li>没有闭包变量问题</li>
<li>没有内存/GC压力</li>
<li>不存在内联回调导致子组件无法永远更新</li>
<li><a href="https://github.com/vuejs/rfcs" target="_blank"> 更多RFC详情</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>1.Vue.js 3.0 还有哪些不足？</p>
<blockquote>
<p>  IE 11 还是会支持，只是会额外花时间来解决。此外，3.0 的劣势都在尽力解决</p>
<ol start="2">
<li>3.0 是否有破坏性的改动？升级效率？<br>这就是 RFC 的价值，所有的重大改变、背后的意义、如何应对这些修改。基本的修改都会有自动化工具来更新。同时会有一个兼容版本，降低更新成本。</li>
<li>React 渲染切片，Vue 仍会有相关成本？<br>切片并非是万能药，只有极端条件下可以完成性能的保障。内部的复杂度较高，实现后仍未能满足性能效果，切片会让 <font style="color:red">nextTick</font> 等代码都有破坏性修改（因为可能是多个 nextTick。</li>
<li>Vue 未来的发展方向？<br>门槛低，价值高。只要有人用，就一直维护和更新</li>
<li>很多企业用户在用 React，因为在 Native 方向有更好的兼容，Vue 未来会对 Native 有更好的兼容吗？<br>一套代码，多端实现。React 虽然有 React Native，但是各个厂家都有相应的对策，Google 有Flutter、Apple 有 SwiftUI，大家不可能让一个开发范式被一个公司使用。恰好，Vue 是独立的开源，没有企业竞争。</li>
</ol>
</blockquote>
<hr>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/自定义指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/自定义指令/" class="post-title-link" itemprop="url">自定义指令</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:22:52 / Modified: 16:46:28" itemprop="dateCreated datePublished" datetime="2019-06-19T15:22:52+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自定义指令directive-混合mixins"><a href="#自定义指令directive-混合mixins" class="headerlink" title="自定义指令directive,混合mixins"></a>自定义指令directive,混合mixins</h2><h3 id="一-自定义指令directive"><a href="#一-自定义指令directive" class="headerlink" title="一.自定义指令directive"></a>一.自定义指令directive</h3><hr>
<h5 id="除了核心功能默认内置的指令-v-model-和-v-show-，Vue-也允许注册自定义指令。注意，在-Vue2-0-中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通-DOM-元素进行底层操作，这时候就会用到自定义指令。"><a href="#除了核心功能默认内置的指令-v-model-和-v-show-，Vue-也允许注册自定义指令。注意，在-Vue2-0-中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通-DOM-元素进行底层操作，这时候就会用到自定义指令。" class="headerlink" title="除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。"></a>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</h5><p>来个实例，当页面加载时，该input元素将获得焦点：</p>
<h4 id="注册一个全局自定义指令-v-focus"><a href="#注册一个全局自定义指令-v-focus" class="headerlink" title="注册一个全局自定义指令 v-focus"></a>注册一个全局自定义指令 <code>v-focus</code></h4><pre><code>Vue.directive(&#39;focus&#39;, {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
</code></pre><h4 id="如果想注册局部指令，组件中也接受一个-directives-的选项："><a href="#如果想注册局部指令，组件中也接受一个-directives-的选项：" class="headerlink" title="如果想注册局部指令，组件中也接受一个 directives 的选项："></a>如果想注册局部指令，组件中也接受一个 <font color="red">directives</font> 的选项：</h4><pre><code>directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
</code></pre><h4 id="然后你可以在模板中任何元素上使用新的-v-focus-属性，如下："><a href="#然后你可以在模板中任何元素上使用新的-v-focus-属性，如下：" class="headerlink" title="然后你可以在模板中任何元素上使用新的 v-focus 属性，如下："></a>然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：</h4><pre><code>&lt;input v-focus&gt;
</code></pre><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><hr>
<h4 id="一个指令定义对象可以提供如下几个钩子函数-均为可选-："><a href="#一个指令定义对象可以提供如下几个钩子函数-均为可选-：" class="headerlink" title="一个指令定义对象可以提供如下几个钩子函数 (均为可选)："></a>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</h4><ul>
<li><font color="red">bind</font>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li><font color="red">inserted</font>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><font color="red">update</font>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
<li><font color="red">componentUpdated</font>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><font color="red">unbind</font>：只调用一次，指令与元素解绑时调用。<h4 id="接下来我们来看一下钩子函数的参数-即-el、binding、vnode-和-oldVnode-。"><a href="#接下来我们来看一下钩子函数的参数-即-el、binding、vnode-和-oldVnode-。" class="headerlink" title="接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。"></a>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</h4><h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4></li>
</ul>
<hr>
<h4 id="指令钩子函数会被传入以下参数："><a href="#指令钩子函数会被传入以下参数：" class="headerlink" title="指令钩子函数会被传入以下参数："></a>指令钩子函数会被传入以下参数：</h4><ul>
<li><font color="red">el</font>:指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li><font color="red">binding</font>:一个对象，包含以下属性: <ul>
<li><font color="red">name</font>:指令名，不包括 v- 前缀。</li>
<li><font color="red">value</font>:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li>
<li><font color="red">oldValue</font>:指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li><font color="red">expression</font>:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>
<li><font color="red">arg</font>: 传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>
<li><font color="red">modifiers</font>:一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>
</ul>
</li>
<li><font color="red">vnode</font>:   Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li>
<li><p><font color="red">oldVnode</font>: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>
<blockquote>
<font color="green">除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <font color="red">dataset</font> 来进行。</font>
</blockquote>
<h3 id="这是一个使用了这些属性的自定义钩子样例："><a href="#这是一个使用了这些属性的自定义钩子样例：" class="headerlink" title="这是一个使用了这些属性的自定义钩子样例："></a>这是一个使用了这些属性的自定义钩子样例：</h3><p>  <div id="hook-arguments-example" v-demo:foo.a.b="message"></div></p>
<pre><code class="js">  Vue.directive(&#39;demo&#39;, {
  bind: function (el, binding, vnode) {
      var s = JSON.stringify
      el.innerHTML =
      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +
      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +
      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; +
      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +
      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +
      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)
  }
  })

  new Vue({
  el: &#39;#hook-arguments-example&#39;,
  data: {
      message: &#39;hello!&#39;
  }
  })
</code></pre>
<p>结果：</p>
<pre><code class="js">  name: &quot;demo&quot;
  value: &quot;hello!&quot;
  expression: &quot;message&quot;
  argument: &quot;foo&quot;
  modifiers: {&quot;a&quot;:true,&quot;b&quot;:true}
  vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder
</code></pre>
<h5 id="在很多时候，你可能想在-bind-和update时触发相同行为，而不关心其它的钩子。比如这样写"><a href="#在很多时候，你可能想在-bind-和update时触发相同行为，而不关心其它的钩子。比如这样写" class="headerlink" title="在很多时候，你可能想在 bind 和update时触发相同行为，而不关心其它的钩子。比如这样写:"></a>在很多时候，你可能想在 bind 和update时触发相同行为，而不关心其它的钩子。比如这样写:</h5><p>  Vue.directive(‘color-swatch’, function (el, binding) {<br>   el.style.backgroundColor = binding.value<br>  })</p>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3></li>
</ul>
<hr>
<h6 id="如果指令需要多个值，可以传入一个-JavaScript-对象字面量。记住，指令函数能够接受所有合法的-JavaScript-表达式。"><a href="#如果指令需要多个值，可以传入一个-JavaScript-对象字面量。记住，指令函数能够接受所有合法的-JavaScript-表达式。" class="headerlink" title="如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。"></a>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。</h6><pre><code>&lt;div v-demo=&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;&gt;&lt;/div&gt;


Vue.directive(&#39;demo&#39;, function (el, binding) {
    console.log(binding.value.color) // =&gt; &quot;white&quot;
    console.log(binding.value.text)  // =&gt; &quot;hello!&quot;
})
</code></pre><h3 id="混合mixins"><a href="#混合mixins" class="headerlink" title="混合mixins"></a>混合mixins</h3><h4 id="混合-mixins-是一种分发-Vue-组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。"><a href="#混合-mixins-是一种分发-Vue-组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。" class="headerlink" title="混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。"></a>混合 (<font color="red">mixins</font>) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</h4><pre><code class="js">        // 定义一个混合对象
    var myMixin = {
    created: function () {
        this.hello()
    },
    methods: {
        hello: function () {
        console.log(&#39;hello from mixin!&#39;)
        }
    }
    }

    // 定义一个使用混合对象的组件
    var Component = Vue.extend({
    mixins: [myMixin]
    })

    var component = new Component() // =&gt; &quot;hello from mixin!&quot;
</code></pre>
<h3 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h3><hr>
<h5 id="当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的-钩子将在组件自身钩子-之前-调用-："><a href="#当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的-钩子将在组件自身钩子-之前-调用-：" class="headerlink" title="当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ："></a>当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ：</h5><pre><code class="js">        var mixin = {
    created: function () {
        console.log(&#39;混合对象的钩子被调用&#39;)
    }
    }

    new Vue({
    mixins: [mixin],
    created: function () {
        console.log(&#39;组件钩子被调用&#39;)
    }
    })

    // =&gt; &quot;混合对象的钩子被调用&quot;
    // =&gt; &quot;组件钩子被调用&quot;
</code></pre>
<h5 id="值为对象的选项，例如-methods-components-和-directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。"><a href="#值为对象的选项，例如-methods-components-和-directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。" class="headerlink" title="值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。"></a>值为对象的选项，例如 <font color="red">methods, components 和 directives</font>，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</h5><pre><code class="js">    var mixin = {
  methods: {
    foo: function () {
      console.log(&#39;foo&#39;)
    },
    conflicting: function () {
      console.log(&#39;from mixin&#39;)
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log(&#39;bar&#39;)
    },
    conflicting: function () {
      console.log(&#39;from self&#39;)
    }
  }
})

vm.foo() // =&gt; &quot;foo&quot;
vm.bar() // =&gt; &quot;bar&quot;
vm.conflicting() // =&gt; &quot;from self&quot;
</code></pre>
<blockquote>
<p>注意：<font color="red">Vue.extend()</font> 也使用同样的策略进行合并。</p>
</blockquote>
<h3 id="全局混合"><a href="#全局混合" class="headerlink" title="全局混合"></a>全局混合</h3><hr>
<h5 id="也可以全局注册混合对象。注意使用！-一旦使用全局混合对象，将会影响到-所有-之后创建的-Vue-实例。使用恰当时，可以为自定义对象注入处理逻辑。"><a href="#也可以全局注册混合对象。注意使用！-一旦使用全局混合对象，将会影响到-所有-之后创建的-Vue-实例。使用恰当时，可以为自定义对象注入处理逻辑。" class="headerlink" title="也可以全局注册混合对象。注意使用！ 一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。"></a>也可以全局注册混合对象。注意使用！ 一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</h5><pre><code>// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: &#39;hello!&#39;
})
// =&gt; &quot;hello!&quot;
</code></pre><blockquote>
<p><font color="red">谨慎使用全局混合对象</font>，因为会影响到每个单独创建的 Vue<br>实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用</p>
</blockquote>
<h3 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h3><hr>
<h5 id="自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向-Vue-config-optionMergeStrategies-添加一个函数："><a href="#自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向-Vue-config-optionMergeStrategies-添加一个函数：" class="headerlink" title="自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数："></a>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 <font color="red">Vue.config.optionMergeStrategies</font> 添加一个函数：</h5><pre><code>Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
    // return mergedVal
}
</code></pre><h5 id="对于大多数对象选项，可以使用-methods-的合并策略："><a href="#对于大多数对象选项，可以使用-methods-的合并策略：" class="headerlink" title="对于大多数对象选项，可以使用 methods 的合并策略："></a>对于大多数对象选项，可以使用 methods 的合并策略：</h5><pre><code>var strategies = Vue.config.optionMergeStrategies
strategies.myOption = strategies.methods
</code></pre><h3 id="结束"><a href="#结束" class="headerlink" title="结束^^"></a>结束^^</h3><hr>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/vue插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/vue插件开发/" class="post-title-link" itemprop="url">vue插件开发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:22:21 / Modified: 15:22:34" itemprop="dateCreated datePublished" datetime="2019-06-19T15:22:21+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="如何去写Vue插件"><a href="#如何去写Vue插件" class="headerlink" title="如何去写Vue插件"></a>如何去写Vue插件</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><h4 id="实现一个简单的提示插件"><a href="#实现一个简单的提示插件" class="headerlink" title="实现一个简单的提示插件"></a>实现一个简单的提示插件</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="官方文档介绍"><a href="#官方文档介绍" class="headerlink" title="官方文档介绍"></a>官方文档介绍</h6><h6 id="插件通常会为Vue提供全局功能。插件的范围没有限制—-一般有以下"><a href="#插件通常会为Vue提供全局功能。插件的范围没有限制—-一般有以下" class="headerlink" title="插件通常会为Vue提供全局功能。插件的范围没有限制—-一般有以下"></a>插件通常会为Vue提供全局功能。插件的范围没有限制—-一般有以下</h6><blockquote>
<ol>
<li>添加全局方法或者属性，如: vue-custom-element </li>
<li>添加全局资源：指令/过滤器/过渡等，如 vue-touch </li>
<li>通过全局 mixin 方法添加一些组件选项，如: vue-router </li>
<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 </li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router</li>
</ol>
</blockquote>
<h5 id="官网给出的代码框架如下"><a href="#官网给出的代码框架如下" class="headerlink" title="官网给出的代码框架如下"></a>官网给出的代码框架如下</h5><pre><code class="js">    Myplugin.install=function(Vue,options){
    //添加全局方法或者属性
        Vue.myGlobalMethods = function(){
            ....逻辑
        }
    }
    //添加全局指令
    Vue.directive(&#39;my-directive&#39;,{
        bind(el,binding,vnode,oldVnode){
            // ...逻辑
        }
        ...
    })
    //注入组件
    Vue.mixin({
        created:function(){
            ...//逻辑
        }
    })
    添加实例方法
    Vue.prototype.$myMethod=function(methodOptions){
        ...逻辑
    }
</code></pre>
<p>下面展示一个提示插件</p>
<h5 id="1-编写组件"><a href="#1-编写组件" class="headerlink" title="1.编写组件"></a>1.编写组件</h5><p>toast.vue</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;m-toast&quot; :class=&quot;{opacity}&quot; v-show=&quot;visible&quot;&gt;&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data () {
    return {
      opacity: false,
      visible: false,
      timer: null,
      html: &#39;&#39;
    }
  },
  mounted () {
  },
  methods: {
    /*
        * html 显示的html片段
        * cb 隐藏之后的回调函数
        * time 自动隐藏时间，-1为不进行隐藏
        * */
    show (html, cb, time) {
      this.html = html
      this.visible = true
      this.$nextTick(() =&gt; {
        this.opacity = true
      })
      window.clearTimeout(this.timer)
      this.timer = window.setTimeout(() =&gt; {
        this.opacity = false
        setTimeout(() =&gt; {
          this.visible = false
        }, 500)
        cb &amp;&amp; cb()
      }, time || 3000)
    },
    hide () {
      this.opacity = false
      setTimeout(() =&gt; {
        this.visible = false
      }, 500)
    }
  }
}
&lt;/script&gt;
&lt;style lang=&quot;less&quot;&gt;

.m-toast {
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed;
  width: 100%;
  left: 0;
  top: 40%;
  z-index: 99999;
  transition: opacity .5s;
  opacity: 0;
  &amp;.opacity{
      opacity: 1;
  }
  p {
    position: relative;
    display: inline-block;
    background: rgba(252,93,123,.5);
    padding: 2% 4%;
    min-width: 20%;
    text-align: center;
    color: #FFF;
    line-height: 1.2;
    border-radius: .2rem;
    font-size: .28rem;
    max-width: 60%;
    line-height: .4rem;
  }
}
&lt;/style&gt;
</code></pre>
<h5 id="2-插件需要有install方法"><a href="#2-插件需要有install方法" class="headerlink" title="2.插件需要有install方法"></a>2.插件需要有install方法</h5><p>toast.js</p>
<pre><code class="js">import Toast from &#39;./index&#39;
export default {
  install (Vue, options = {}) {
    const VueToast = Vue.extend(Toast)
    let toast = null
    function $toast (html, cb, time) {
      return new Promise(resolve =&gt; {
        if (!toast) {
          toast = new VueToast()

          toast.$mount()

          document.querySelector(options.container || &#39;body&#39;).appendChild(toast.$el)
        }
        toast.show(html, cb, time)
        resolve()
      })
    }

    Vue.prototype.$toast = $toast
  }
}
</code></pre>
<h5 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h5><pre><code>  this.$toast(&#39;今日输送能量任务已完成明天再来吧~&#39;)
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/sync使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/sync使用/" class="post-title-link" itemprop="url">sync使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:21:41 / Modified: 16:44:14" itemprop="dateCreated datePublished" datetime="2019-06-19T15:21:41+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Sync的使用"><a href="#Sync的使用" class="headerlink" title="Sync的使用"></a>Sync的使用</h5><blockquote>
<p>在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的<font color="red"> .sync </font>修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。</p>
</blockquote>
<blockquote>
<p>在2.0发布一段之后，无论在业务组件还是在功能组件库上面的，大量的子组件改变父子组件的数据和组件库中可能达到大功率的复用，但是在2.3中回归，重新引入了 .sync 修饰符，这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。<br>之前的例子中，v-model 毕竟不是给组件与组件之间通信而设计的双向绑定，无论从语意上和代码写法上都没有 .sync 直观和方便。<br>无论从 v-model 还是 .sync 修饰符来看，都离不开 $emit v-on 语法糖的封装，主要目的还是为了保证数据的正确单向流动与显示流动。</p>
</blockquote>
<pre><code>&lt;demo :foo.sync=&quot;something&quot;&gt;&lt;/demo&gt;
</code></pre><h6 id="语法糖的扩展"><a href="#语法糖的扩展" class="headerlink" title="语法糖的扩展"></a>语法糖的扩展</h6><pre><code>&lt;demo :foo=&quot;something&quot; @update:foo=&quot;val =&gt; something = val&quot;&gt;&lt;/demo&gt;
</code></pre><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><ul>
<li>foo 则是 demo 子组件需要从父组件 props 接收的数据</li>
<li><p>通过事件显示监听 update:foo (foo则是 props 显示监听的数据)，通过箭头函数执行回调，把参数传给 something，则就形成了一种双向绑定的循环链条</p>
<h6 id="当子组件需要更新-foo-的值时，它需要显式地触发一个更新事件："><a href="#当子组件需要更新-foo-的值时，它需要显式地触发一个更新事件：" class="headerlink" title="当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件："></a>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</h6><p>this.$emit(‘update:foo’, newValue)<br>同时父组件<font color="red">@update:foo</font>也是依赖于子组件的显示触发，这样就可以很轻松的捕捉到了数据的正确的流动。<br>第一个参数则是 <font color="red">update 显示更新的事件</font>，跟在后面的：foo则是需要<font color="red">改变对应的props值</font>。<br>第二个参数传入的是你希望父组件<font color="red">foo数据里将要变化的值</font>，以用于父组件接收update时更新数据。</p>
<h5 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h5><pre><code class="js">&lt;template&gt;
&lt;div v-show=&quot;show&quot;&gt;
    &lt;p&gt;这是一个Model框&lt;/p&gt;
    &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    props: [&#39;show&#39;],
    methods: {
        closeModel () {
        this.$emit(&#39;update:show&#39;,false)
        }
    }
}
&lt;/script&gt;
</code></pre>
<h5 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h5><pre><code class="js">&lt;template&gt;
&lt;div class=&quot;hello&quot;&gt;
    &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt;
    &lt;demo :show.sync=&quot;show&quot; &gt;&lt;/demo&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Demo from &#39;./Demo.vue&#39;
export default {
    name: &#39;hello&#39;,
    components: {
        Demo
    },
    data () {
        return {
            show: false
        }
    }
}
&lt;/script&gt;
</code></pre>
<h6 id="上面的-case-同样也解决了-model-显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了-v-model-做不了的事，基于-props-的原子化，对传入的-props-进行多个数据双向绑定-sync-也能轻松做到。"><a href="#上面的-case-同样也解决了-model-显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了-v-model-做不了的事，基于-props-的原子化，对传入的-props-进行多个数据双向绑定-sync-也能轻松做到。" class="headerlink" title="上面的 case 同样也解决了 model 显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了 v-model 做不了的事，基于 props 的原子化，对传入的 props 进行多个数据双向绑定.sync 也能轻松做到。"></a>上面的 case 同样也解决了 model 显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了 v-model 做不了的事，基于 props 的原子化，对传入的 props 进行多个数据双向绑定.sync 也能轻松做到。</h6><h5 id="父组件-1"><a href="#父组件-1" class="headerlink" title="父组件"></a>父组件</h5></li>
</ul>
<pre><code class="js">&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt;
    &lt;demo :show.sync=&quot;show&quot; :msg.sync=&quot;msg&quot;&gt;&lt;/demo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Demo from &#39;./Demo.vue&#39;
  export default {
    name: &#39;hello&#39;,
    components: {
      Demo
    },
    data () {
      return {
        show: false,
        msg: &#39;这是一个model&#39;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h5 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h5><pre><code class="js">&lt;template&gt;
   &lt;div v-show=&quot;show&quot;&gt;
      &lt;p&gt;{{msg}}&lt;/p&gt;
      &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt;
     &lt;button @click=&quot;$emit(&#39;update:msg&#39;,&#39;改变了model文案&#39;)&quot;&gt;改变文案&lt;/button&gt;
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: [&#39;show&#39;, &#39;msg&#39;],
  methods: {
    closeModel () {
      this.$emit(&#39;update:show&#39;,false)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="warn"><a href="#warn" class="headerlink" title="warn"></a><font color="red">warn</font></h3><blockquote>
<p>子组件改变父组件的数据时，update 冒号后面的参数和父组件传递进来的值是同步的，想改变那个，则冒号后面的值对应的那个，两者是一一对应的，同时也是必填的。<br>同样还可以在组件 template 里点击执行 click 后不但可以支持回调函数，还可以写入表达式，只是一种直观的表现还是推荐这种写法的。<br>.sync 修饰符给我们开发中带来了很大的方便，同时在2.0的初期的组件库中大量的 v-model 给开发者用起来还是很别扭，在.sync 回归后同时也会慢慢向.sync 进行一个版本的迁移。</p>
</blockquote>
<h3 id="END—-下一次分享-attrs-listeners使用"><a href="#END—-下一次分享-attrs-listeners使用" class="headerlink" title="END—  下一次分享$attrs $listeners使用"></a>END—  下一次分享$attrs $listeners使用</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/��使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/��使用/" class="post-title-link" itemprop="url">$attr使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:20:23 / Modified: 16:35:19" itemprop="dateCreated datePublished" datetime="2019-06-19T15:20:23+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="attrs与-listenrs使用"><a href="#attrs与-listenrs使用" class="headerlink" title="$attrs与$listenrs使用"></a>$attrs与$listenrs使用</h3><blockquote>
<p>2.4.0 新增</p>
<ul>
<li>类型：<font color="orange">{ [key: string]: string }</font></li>
<li>只读</li>
<li>详细:</li>
</ul>
</blockquote>
<h4 id="包含了父作用域中不作为-prop-被识别-且获取-的特性绑定-class-和-style-除外-。当一个组件没有声明任何-prop-时，这里会包含所有父作用域的绑定-class-和-style-除外-，并且可以通过-v-bind-”-attrs”-传入内部组件——在创建高级别的组件时非常有用。"><a href="#包含了父作用域中不作为-prop-被识别-且获取-的特性绑定-class-和-style-除外-。当一个组件没有声明任何-prop-时，这里会包含所有父作用域的绑定-class-和-style-除外-，并且可以通过-v-bind-”-attrs”-传入内部组件——在创建高级别的组件时非常有用。" class="headerlink" title="包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。"></a>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (<font color="orange">class 和 style 除外)</font>。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过<font color="orange"> v-bind=”$attrs”</font> 传入内部组件——在创建高级别的组件时非常有用。</h4><h5 id="官方说法似乎有点模糊-其实可以这么去理解"><a href="#官方说法似乎有点模糊-其实可以这么去理解" class="headerlink" title="官方说法似乎有点模糊 其实可以这么去理解"></a>官方说法似乎有点模糊 其实可以这么去理解</h5><pre><code>因为在项目中深层次组件交互的话可能就需要 Vuex 助力了，但是如果只是一个简单的深层次数据传递，

或者进行某种交互时需要向上通知顶层或父层组件数据改变时，大材小用Vuex可能未免有点多余！
</code></pre><h4 id="attr-与-interitAttrs-之间的关系"><a href="#attr-与-interitAttrs-之间的关系" class="headerlink" title="$attr 与 interitAttrs 之间的关系"></a><font color="red">$attr 与 interitAttrs 之间的关系</font></h4><h4 id="interitAttrs："><a href="#interitAttrs：" class="headerlink" title="interitAttrs："></a>interitAttrs：</h4><blockquote>
<p>2.4.0 新增</p>
<ul>
<li>类型：<font color="orange">boolean</font></li>
<li>默认值：<font color="orange">true</font></li>
<li>详细:</li>
</ul>
</blockquote>
<h4 id="默认情况下父作用域的不被认作-props-的特性绑定-attribute-bindings-将会“回退”且作为普通的-HTML-特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置-inheritAttrs-到-false，这些默认行为将会被去掉。而通过-同样是-2-4-新增的-实例属性-attrs-可以让这些特性生效，且可以通过-v-bind-显性的绑定到非根元素上。"><a href="#默认情况下父作用域的不被认作-props-的特性绑定-attribute-bindings-将会“回退”且作为普通的-HTML-特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置-inheritAttrs-到-false，这些默认行为将会被去掉。而通过-同样是-2-4-新增的-实例属性-attrs-可以让这些特性生效，且可以通过-v-bind-显性的绑定到非根元素上。" class="headerlink" title="默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。"></a>默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。</h4><h2 id="warn：这个选项不影响-class-和-style-绑定。"><a href="#warn：这个选项不影响-class-和-style-绑定。" class="headerlink" title="warn：这个选项不影响 class 和 style 绑定。"></a><font color="red">warn：这个选项不影响 class 和 style 绑定。</font></h2><h4 id="下面通过简单demo解释下"><a href="#下面通过简单demo解释下" class="headerlink" title="下面通过简单demo解释下"></a>下面通过简单demo解释下</h4><p>父组件</p>
<pre><code class="js">&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
     &lt;demo :count=&quot;count&quot; :num=&quot;num&quot;&gt;&lt;/demo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Demo from &#39;./demo.vue&#39;
  export default {
    name: &#39;hello&#39;,
    components: {
      Demo
    },
    data () {
      return {
        count: &#39;count message&#39;,
        num: &#39;num message&#39;
      }
    },
  }
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code class="js">&lt;template&gt;
   &lt;div&gt;
      {{count}}
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
   name: &#39;demo&#39;,
   props: [&#39;count&#39;]
}
&lt;/script&gt;
</code></pre>
<h5 id="父组件在子组件中进行传递-count-和num-两个数据，在子组件中，应该有相对应的-props-定义的接收点，如果在-props-中定义了，你会发现无论是-count-和-num-都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。"><a href="#父组件在子组件中进行传递-count-和num-两个数据，在子组件中，应该有相对应的-props-定义的接收点，如果在-props-中定义了，你会发现无论是-count-和-num-都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。" class="headerlink" title="父组件在子组件中进行传递 count 和num 两个数据，在子组件中，应该有相对应的 props 定义的接收点，如果在 props 中定义了，你会发现无论是 count 和 num 都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。"></a>父组件在子组件中进行传递 count 和num 两个数据，在子组件中，应该有相对应的 props 定义的接收点，如果在 props 中定义了，你会发现无论是 count 和 num 都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。</h5><p>虽然在父组件中在子组件模版上通过 props 定义了两个数据，但是子组件中的 props 只接收了一个，只接收了 count，并没有接收 num，没有进行接收的此时就会成为<font color="red">子组件根无素的属性节点。</font></p>
<h5 id="interitAttrs-false-发生了什么-？"><a href="#interitAttrs-false-发生了什么-？" class="headerlink" title="interitAttrs = false 发生了什么 ？"></a>interitAttrs = false 发生了什么 ？</h5><p>子组件</p>
<pre><code class="js">&lt;template&gt;
   &lt;div&gt;
      {{count}}
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
   name: &#39;demo&#39;,
   props: [&#39;count&#39;],
   interitAttrs:false
}
&lt;/script&gt;
</code></pre>
<h4 id="对子组件进行一个改动，我们加上-inheritAttrs-false，从字面上的翻译的意思，取消继承的属性，然而-props-里仍然没有接收-num，发现就算-props-里没有接收-num，在子组件的根元素上并没有绑定任何属性。"><a href="#对子组件进行一个改动，我们加上-inheritAttrs-false，从字面上的翻译的意思，取消继承的属性，然而-props-里仍然没有接收-num，发现就算-props-里没有接收-num，在子组件的根元素上并没有绑定任何属性。" class="headerlink" title="对子组件进行一个改动，我们加上 inheritAttrs: false，从字面上的翻译的意思，取消继承的属性，然而 props 里仍然没有接收 num，发现就算 props 里没有接收 num，在子组件的根元素上并没有绑定任何属性。"></a>对子组件进行一个改动，我们加上 inheritAttrs: false，从字面上的翻译的意思，取消继承的属性，然而 props 里仍然没有接收 num，发现就算 props 里没有接收 num，在子组件的根元素上并没有绑定任何属性。</h4><blockquote>
<p>$attrs</p>
</blockquote>
<p>在前面的例子中，子组件props中并没有接受num，设置选项 inheritAttrs： false，同样也不会作为根元素的属性节点，整个没有接收的数据都被 $attr 实例属性给接收，里面包含着所有父组件传入而子组件并没有在 Props里显示接收的数据。</p>
<p>为了验证事实，可以在子组件中加上</p>
<pre><code>    created () {
       console.log(this.$attrs)
    }
</code></pre><p>打印出来则是一个对象 {num: “num message”}</p>
<h3 id="warn"><a href="#warn" class="headerlink" title="warn"></a><font color="red">warn</font></h3><p>想要通 $attr 接收，但必须要保证设置选项<font color="red"> inheritAttrs: false，</font>不然会默认变成根元素的属性节点。<br>开头说了，最有用的情况则是在深层次组件运用的时候，创建第三层孙子组件，作为第二层父组件的子组件，在子组件引入的孙子组件，在模版上把整个 $attr 当数作数据传递下去，中间则并不用通过任何方法去手动转换数据。<br>子组件</p>
<pre><code class="js">&lt;template&gt;
   &lt;div&gt;
      &lt;next-demo v-bind=&quot;$attrs&quot;&gt;&lt;/next-demo&gt;
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import nextDemo from &#39;./nextdemo.vue&#39;
export default {
   name: &#39;demo&#39;,
   components: {
      nextDemo
    },
   created () {
       console.log(this.$attrs)
    }
}
&lt;/script&gt;
</code></pre>
<p>孙子组件</p>
<pre><code class="js">&lt;template&gt;
  &lt;div&gt;
      {{count}}{{num}}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
     props : [ &#39;count&#39; , &#39;num&#39;]
  }
&lt;/script&gt;
</code></pre>
<h4 id="孙子组件在-props-接收子组件中通过-attrs-包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了-attrs进行了统一接收，再往下传递，最后通过孙子组件进行接收。"><a href="#孙子组件在-props-接收子组件中通过-attrs-包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了-attrs进行了统一接收，再往下传递，最后通过孙子组件进行接收。" class="headerlink" title="孙子组件在 props 接收子组件中通过 $attrs 包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了$attrs进行了统一接收，再往下传递，最后通过孙子组件进行接收。"></a>孙子组件在 props 接收子组件中通过 <font color="red">$attrs</font> 包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了<font color="red">$attrs</font>进行了统一接收，再往下传递，最后通过孙子组件进行接收。</h4><p>以此类推孙子组件仍然不想接收，再传入下级组件，我们仍然需要对孙子组件实力选项进行设置选项 inheritAttrs: false，否则仍然会成为孙子组件根元素的属性节点。</p>
<h2 id="从而利用-attrs-来接收-props-为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。"><a href="#从而利用-attrs-来接收-props-为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。" class="headerlink" title="从而利用 $attrs 来接收 props 为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。"></a>从而利用 <font color="red">$attrs</font> 来接收 props 为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。</h2><h4 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h4><blockquote>
<p>2.4.0 新增</p>
<ul>
<li>类型：<font color="orange">{ [key: string]: Function | Array<function> }</function></font></li>
<li>只读</li>
<li>详细:</li>
</ul>
</blockquote>
<pre><code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。

$listeners 和 $attrs 两者表面层都是一个意思，$attrs 是向下传递数据，$listeners 是向下传递方法，通过手动去调用 $listeners 对象里的方法，原理就是 $emit 监听事件，$listeners 也可以看成一个包裹监听事件的一个对象。
父组件
``` js
&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
     {{firstMsg}}
     &lt;demo v-on:changeData=&quot;changeData&quot; v-on:another = &#39;another&#39;&gt;&lt;/demo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Demo from &#39;./demo.vue&#39;
  export default {
    name: &#39;hello&#39;,
    components: {
      Demo
    },
    data () {
      return {
        firstMsg: &#39;父组件&#39;,
      }
    },
    methods: {
      changeData (params) {
         this.firstMsg = params
      },
      another () {
        alert(2)
      }
    }
  }
&lt;/script&gt;
```
子组件
```js
&lt;template&gt;
   &lt;div&gt;
      &lt;p @click=&quot;$emit(&#39;another&#39;)&quot;&gt;子组件&lt;/p&gt;  
      &lt;next-demo  v-on=&#39;$listeners&#39;&gt;&lt;/next-demo&gt;
   &lt;/div&gt;

&lt;/template&gt;
&lt;script&gt;
import NextDemo from &#39;./nextdemo.vue&#39;
export default {
   name: &#39;demo&#39;,
   components: {
       NextDemo
   },
   created () {
     console.log(this.$listeners)
   },
}
&lt;/script&gt;
```
  孙子组件
```js
&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
      &lt;p @click=&#39;$listeners.changeData(&quot;change&quot;)&#39;&gt;孙子组件&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;demo&#39;,
  created () {
      console.log(this.$listeners)
  },
}
&lt;/script&gt;
```
</code></pre><h3 id="依然能拿到从子组中传递过来的-listeners所有的监听事件，此时并不是通过-emit去触发，而是像调用函数一样，-emit只是针对于父子组件的双向通信，-listeners包了一个对象，分别是-changeData-和-another，通过-listeners-changeData-‘change’-等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。"><a href="#依然能拿到从子组中传递过来的-listeners所有的监听事件，此时并不是通过-emit去触发，而是像调用函数一样，-emit只是针对于父子组件的双向通信，-listeners包了一个对象，分别是-changeData-和-another，通过-listeners-changeData-‘change’-等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。" class="headerlink" title="依然能拿到从子组中传递过来的$listeners所有的监听事件，此时并不是通过$emit去触发，而是像调用函数一样，$emit只是针对于父子组件的双向通信，$listeners包了一个对象，分别是 changeData 和 another，通过$listeners.changeData(‘change’)等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。"></a>依然能拿到从子组中传递过来的$listeners所有的监听事件，此时并不是通过$emit去触发，而是像调用函数一样，$emit只是针对于父子组件的双向通信，<font color="red">$listeners包了一个对象，分别是 changeData 和 another，通过$listeners.changeData(‘change’)等于直接触发了事件</font>，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。</h3><p>通过 $attrs 和 $listeners 可以很愉快地解决深层次组件的通信问题，更加合理的组织你的代码。</p>
<h3 id="END-—下次分享-parent-children使用"><a href="#END-—下次分享-parent-children使用" class="headerlink" title="END —下次分享$parent $children使用"></a>END —下次分享$parent $children使用</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2019/06/19/vModel语法糖/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/19/vModel语法糖/" class="post-title-link" itemprop="url">vModel语法糖</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-19 15:18:34 / Modified: 16:32:34" itemprop="dateCreated datePublished" datetime="2019-06-19T15:18:34+08:00">2019-06-19</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="v-model语法糖"><a href="#v-model语法糖" class="headerlink" title="v-model语法糖"></a>v-model语法糖</h3><blockquote>
<p>什么是v-model语法糖 如何去理解这个语法糖</p>
</blockquote>
<h4 id="v-model-其实也是一个语法糖，想要理解语法糖，你首先要知道Input元素上本身有个-oninput事件，这是HTML5新增加的，类似onchange，每当输入框内容发生变化的时候，就会触发这个事件，然后把-Input-输入框中"><a href="#v-model-其实也是一个语法糖，想要理解语法糖，你首先要知道Input元素上本身有个-oninput事件，这是HTML5新增加的，类似onchange，每当输入框内容发生变化的时候，就会触发这个事件，然后把-Input-输入框中" class="headerlink" title="v-model 其实也是一个语法糖，想要理解语法糖，你首先要知道Input元素上本身有个  oninput事件，这是HTML5新增加的，类似onchange，每当输入框内容发生变化的时候，就会触发这个事件，然后把 Input 输入框中"></a>v-model 其实也是一个语法糖，想要理解语法糖，你首先要知道Input元素上本身有个  oninput事件，这是HTML5新增加的，类似onchange，每当输入框内容发生变化的时候，就会触发这个事件，然后把 Input 输入框中</h4><p>value 值再次传递给 newValue。<br>此时 value 运用在一个 Input 元素上，用：v-bind:value=’newValue’，意义上面只是把Input 输入框中的 value 值与 newValue 作为一一对应的双向绑定，这就像一个循环操作，当再次触发 Input 事件时，input($event.target)对象中的value值会再次改变newValue。<br>这里我们对 v-model 绑定在 Input 元素上进行语法糖上的解析。</p>
<h5 id="在组件中使用的时候-它相当于"><a href="#在组件中使用的时候-它相当于" class="headerlink" title="在组件中使用的时候 它相当于"></a>在组件中使用的时候 它相当于</h5><pre><code class="javascript">&lt;custom-input&gt;
    v-bind:value=&quot;newValue&quot;
    v-on:input = &quot;newValue = argument[0]&quot;
&lt;/custom-input&gt;

</code></pre>
<h5 id="通过以上简写-通过自定义事件实现父子数据双向绑定"><a href="#通过以上简写-通过自定义事件实现父子数据双向绑定" class="headerlink" title="通过以上简写,通过自定义事件实现父子数据双向绑定"></a>通过以上简写,通过自定义事件实现父子数据双向绑定</h5><pre><code>v-bind:value=&#39;newValue&#39; 此时 value 是作为子组件接收的 Props
</code></pre><h5 id="接收的只能是-value-吗？必须是，因为-v-model-是基于-Input-输入框定制的，其中value-值是为-Input-内部定制的"><a href="#接收的只能是-value-吗？必须是，因为-v-model-是基于-Input-输入框定制的，其中value-值是为-Input-内部定制的" class="headerlink" title="接收的只能是 value 吗？必须是，因为 v-model 是基于 Input 输入框定制的，其中value 值是为 Input 内部定制的"></a>接收的只能是 value 吗？必须是，因为 v-model 是基于 Input 输入框定制的，其中value 值是为 Input 内部定制的</h5><pre><code>v-on:input=&quot;newValue = arguments[0]&quot;
</code></pre><h5 id="此时作用在组件上时，v-on-监听的语法糖也会有所改动，监听的并不是-event-target-value，而是回调函数中的第一个参数"><a href="#此时作用在组件上时，v-on-监听的语法糖也会有所改动，监听的并不是-event-target-value，而是回调函数中的第一个参数" class="headerlink" title="此时作用在组件上时，v-on 监听的语法糖也会有所改动，监听的并不是$event.target.value，而是回调函数中的第一个参数"></a>此时作用在组件上时，v-on 监听的语法糖也会有所改动，监听的并不是<font color="red">$event.target.value</font>，而是回调函数中的第一个参数</h5><h4 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h4><pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt;
    &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Demo from &#39;./Demo.vue&#39;
export default {
  name: &#39;hello&#39;,
  components: {
    Demo
  },
  data () {
    return {
      show: false
    }
  }
}

</code></pre>
<h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><pre><code class="js">&lt;template&gt;
   &lt;div v-show=&quot;value&quot;&gt;
      &lt;div&gt;
         &lt;p&gt;这是一个Model框&lt;/p&gt;
         &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: [&#39;value&#39;],
  methods: {
    close () {
      this.$emit(&#39;input&#39;,false)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 id="这是一个模态框的基本雏形，可以在父组件通过-v-model-来进行-model-框和父组件之间的显示交互。"><a href="#这是一个模态框的基本雏形，可以在父组件通过-v-model-来进行-model-框和父组件之间的显示交互。" class="headerlink" title="这是一个模态框的基本雏形，可以在父组件通过 v-model 来进行 model 框和父组件之间的显示交互。"></a>这是一个模态框的基本雏形，可以在父组件通过 v-model 来进行 model 框和父组件之间的显示交互。</h4><p>通过子组件看出通过props接收了value值，当点击关闭的时候还是通过$emit事件触发input事件，然后通过传入 false 参数。</p>
<p>父组件隐式 v-on:input=”something = arguments[0]” 进行了监听，一但 Input</p>
<p>事件触发，父组件就会执行监听回调，从而做到了双向绑定。</p>
<h3 id="定制组件-v-model"><a href="#定制组件-v-model" class="headerlink" title="定制组件 v-model"></a><strong><em>定制组件 v-model</em></strong></h3><hr>
<h5 id="父组件-1"><a href="#父组件-1" class="headerlink" title="父组件"></a>父组件</h5><h5 id="定制组件，我们就可以重写v-model里的Props-和-event，默认情况下，一个组件的-v-model-会使用-value-属性和-input-事件，往往有些时候，value-值被占用了，或者表单的和自定义v-model的-emit-‘input’-事件发生冲突，为了避免这种冲突，可以定制组件-v-model，冲突示例。"><a href="#定制组件，我们就可以重写v-model里的Props-和-event，默认情况下，一个组件的-v-model-会使用-value-属性和-input-事件，往往有些时候，value-值被占用了，或者表单的和自定义v-model的-emit-‘input’-事件发生冲突，为了避免这种冲突，可以定制组件-v-model，冲突示例。" class="headerlink" title="定制组件，我们就可以重写v-model里的Props 和 event，默认情况下，一个组件的 v-model 会使用 value 属性和 input 事件，往往有些时候，value 值被占用了，或者表单的和自定义v-model的$emit(‘input’)事件发生冲突，为了避免这种冲突，可以定制组件 v-model，冲突示例。"></a>定制组件，我们就可以<font color="red">重写v-model里的Props 和 event</font>，默认情况下，一个组件的 v-model 会使用 value 属性和 input 事件，往往有些时候，value 值被占用了，或者表单的和自定义<font color="green">v-model的$emit(‘input’)</font>事件发生冲突，为了避免这种冲突，可以定制组件 v-model，冲突示例。</h5><h6 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h6><pre><code class="js">&lt;template&gt;
   &lt;div v-show=&quot;value&quot;&gt;
      &lt;div&gt;
         &lt;p&gt;这是一个Model框&lt;/p&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt;
        {{value}}
         &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: [&#39;value&#39;],
  methods: {
    close () {
      this.$emit(&#39;input&#39;,false)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h6 id="父组件-2"><a href="#父组件-2" class="headerlink" title="父组件"></a>父组件</h6><pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt;
    &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Demo from &#39;./Demo.vue&#39;
  export default {
    name: &#39;hello&#39;,
    components: {
      Demo
    },
    data () {
      return {
        show: false
      }
    }
  }
&lt;/script&gt;
</code></pre><h5 id="上面例子可以发现，在子组件中input中v-model和model显示的操作数据共同占用的-props"><a href="#上面例子可以发现，在子组件中input中v-model和model显示的操作数据共同占用的-props" class="headerlink" title="上面例子可以发现，在子组件中input中v-model和model显示的操作数据共同占用的 props"></a>上面例子可以发现，在子组件中input中v-model和model显示的操作数据共同占用的 props</h5><p>中的（value），同样两者也共同占用了 emit(‘input’) 触发事件，Input 输入框的事件是自动出发，而 model<br>显示消失是手动触发。</p>
<p>初始化的时候，Input 输入框的值的会被 value 传入的 false 值给自动加上，当改变 Input<br>输入框的时候，因为冲突而导致报错。</p>
<p>定制 v-model， <font color="red">通过 model 选项改变 props 和 event 的值</font>，从而解除两者的冲突。</p>
<ul>
<li>props代替掉原本 value 的值，可以自定义值</li>
<li><p>event代表掉原本 input 的触发事件，可以自定义触发事件</p>
<h5 id="子组件-2"><a href="#子组件-2" class="headerlink" title="子组件"></a>子组件</h5><pre><code class="js">  &lt;template&gt;
  &lt;div v-show=&quot;show&quot;&gt;
      &lt;div&gt;
          &lt;p&gt;这是一个Model框&lt;/p&gt;
          &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt;
          {{value}}
          &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt;
      &lt;/div&gt;
  &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  export default {
  model: {
      prop: &#39;show&#39;,
      event: &#39;close&#39;
  },
  props: [&#39;show&#39;],
  data () {
      return {
      value: 10
      }
  },
  methods: {
      closeModel () {
      this.$emit(&#39;close&#39;,false)
      }
  }
  }
  &lt;/script&gt;
</code></pre>
<h5 id="通过-model-选项的改变，把-props-从原本的value换成了show，input触发的事件换成了close，从而两者都不相互依赖，解决了冲突的问题。"><a href="#通过-model-选项的改变，把-props-从原本的value换成了show，input触发的事件换成了close，从而两者都不相互依赖，解决了冲突的问题。" class="headerlink" title="通过 model 选项的改变，把 props 从原本的value换成了show，input触发的事件换成了close，从而两者都不相互依赖，解决了冲突的问题。"></a>通过 model 选项的改变，把 props 从<font color="red">原本的value换成了show，input触发的事件换成了close</font>，从而两者都不相互依赖，解决了冲突的问题。</h5></li>
</ul>
<p>有些时候通过父组件中的子组件模板中想传递<br>value 值，也会导致同样的冲突。</p>
<p>在不用定制组件的情况下，以下的写法，也会同样导致冲突，导致同用一个 value。</p>
<h4 id><a href="#" class="headerlink" title></a><demo v-model="show" value="some value"></demo></h4><pre><code>props:[&#39;value&#39;]
</code></pre><hr>
<h3 id="END—-下一次分享-sync的使用-改变数据流单向流"><a href="#END—-下一次分享-sync的使用-改变数据流单向流" class="headerlink" title="END—  下一次分享  sync的使用 改变数据流单向流"></a>END—  下一次分享  <em>sync</em>的使用 改变数据流单向流</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lifenglei/2018/08/10/my-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="端端">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://static.soyoung.com/sy-pre/logo-1560924611786.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/08/10/my-blog/" class="post-title-link" itemprop="url">如何开发一个登录注册组件</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-10 17:12:13 / Modified: 17:15:17" itemprop="dateCreated datePublished" datetime="2018-08-10T17:12:13+08:00">2018-08-10</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="如何开发一个登录注册组件"><a href="#如何开发一个登录注册组件" class="headerlink" title="如何开发一个登录注册组件"></a>如何开发一个登录注册组件</h3><h6 id="要开发某个功能我们就要去思考这个功能怎样实现最快捷最方便，下面以项目中的登录注册组件为例说明"><a href="#要开发某个功能我们就要去思考这个功能怎样实现最快捷最方便，下面以项目中的登录注册组件为例说明" class="headerlink" title="要开发某个功能我们就要去思考这个功能怎样实现最快捷最方便，下面以项目中的登录注册组件为例说明"></a>要开发某个功能我们就要去思考这个功能怎样实现最快捷最方便，下面以项目中的登录注册组件为例说明</h6><hr>
<h5 id="一个功能要尽可能的去拆分比如这个登录注册组件就可以拆分成三个部分"><a href="#一个功能要尽可能的去拆分比如这个登录注册组件就可以拆分成三个部分" class="headerlink" title="一个功能要尽可能的去拆分比如这个登录注册组件就可以拆分成三个部分"></a>一个功能要尽可能的去拆分比如这个登录注册组件就可以拆分成三个部分</h5><h6 id="一：登录"><a href="#一：登录" class="headerlink" title="一：登录"></a>一：登录</h6><h6 id="二-：注册"><a href="#二-：注册" class="headerlink" title="二 ：注册"></a>二 ：注册</h6><h6 id="三：其他（example-找回密码）"><a href="#三：其他（example-找回密码）" class="headerlink" title="三：其他（example:找回密码）"></a>三：其他（example:找回密码）</h6><h6 id="组件好写-这里就不在去写了-（组件就是可以重复利用的片段）"><a href="#组件好写-这里就不在去写了-（组件就是可以重复利用的片段）" class="headerlink" title="组件好写 这里就不在去写了 （组件就是可以重复利用的片段）"></a>组件好写 这里就不在去写了 （组件就是可以重复利用的片段）</h6><h6 id="这里我先梳理思路"><a href="#这里我先梳理思路" class="headerlink" title="这里我先梳理思路"></a>这里我先梳理思路</h6><h6 id="我们要写一个全局方法-可以控制哪个组件显示-类似于这样this-setLogShow-n"><a href="#我们要写一个全局方法-可以控制哪个组件显示-类似于这样this-setLogShow-n" class="headerlink" title="我们要写一个全局方法 可以控制哪个组件显示 类似于这样this.setLogShow(n)"></a>我们要写一个全局方法 可以控制哪个组件显示 类似于这样this.setLogShow(n)</h6><h6 id="里面可以是Blooean-或者Number-比如登陆组件要显示-可以传入Number-1-注册组件为2-等"><a href="#里面可以是Blooean-或者Number-比如登陆组件要显示-可以传入Number-1-注册组件为2-等" class="headerlink" title="里面可以是Blooean 或者Number 比如登陆组件要显示 可以传入Number 1 ,注册组件为2 等"></a>里面可以是Blooean 或者Number 比如登陆组件要显示 可以传入Number 1 ,注册组件为2 等</h6><h6 id="下面我们来完善自己的仓库-log-js"><a href="#下面我们来完善自己的仓库-log-js" class="headerlink" title="下面我们来完善自己的仓库(log.js)"></a>下面我们来完善自己的仓库(log.js)</h6><h6 id="为了能让你学到更多东西我采用手动写代码方式"><a href="#为了能让你学到更多东西我采用手动写代码方式" class="headerlink" title="为了能让你学到更多东西我采用手动写代码方式"></a>为了能让你学到更多东西我采用手动写代码方式</h6><h4 id="首先要明白下面四点"><a href="#首先要明白下面四点" class="headerlink" title="首先要明白下面四点"></a>首先要明白下面四点</h4><h4 id="第一：vue是数据驱动-数据改变会会更新视图-我们需要有一个初始状态值-state"><a href="#第一：vue是数据驱动-数据改变会会更新视图-我们需要有一个初始状态值-state" class="headerlink" title="第一：vue是数据驱动 数据改变会会更新视图  我们需要有一个初始状态值 state;"></a>第一：vue是数据驱动 数据改变会会更新视图  我们需要有一个初始状态值 state;</h4><h4 id="第二：-vue中的数据是加了钩子的-不管是get-或者set-都会触发钩子-getter是在显示数据之前进行的在编辑"><a href="#第二：-vue中的数据是加了钩子的-不管是get-或者set-都会触发钩子-getter是在显示数据之前进行的在编辑" class="headerlink" title="第二： vue中的数据是加了钩子的 不管是get 或者set 都会触发钩子 getter是在显示数据之前进行的在编辑;"></a>第二： vue中的数据是加了钩子的 不管是get 或者set 都会触发钩子 getter是在显示数据之前进行的在编辑;</h4><h4 id="第三：数据状态的改变只能通过Mutations-同步修改状态"><a href="#第三：数据状态的改变只能通过Mutations-同步修改状态" class="headerlink" title="第三：数据状态的改变只能通过Mutations 同步修改状态;"></a>第三：数据状态的改变只能通过Mutations 同步修改状态;</h4><h4 id="第四：Actions-异步修改状态-且只能提交到Mutations"><a href="#第四：Actions-异步修改状态-且只能提交到Mutations" class="headerlink" title="第四：Actions  异步修改状态 且只能提交到Mutations;"></a>第四：Actions  异步修改状态 且只能提交到Mutations;</h4><h6 id="理解了上面四点我们开始构建我们的logIn仓库"><a href="#理解了上面四点我们开始构建我们的logIn仓库" class="headerlink" title="理解了上面四点我们开始构建我们的logIn仓库"></a>理解了上面四点我们开始构建我们的logIn仓库</h6><h5 id="一下代码均按照所在公司要求编写"><a href="#一下代码均按照所在公司要求编写" class="headerlink" title="一下代码均按照所在公司要求编写"></a>一下代码均按照所在公司要求编写</h5><h6 id="首先我们需要定义项目存在的事件"><a href="#首先我们需要定义项目存在的事件" class="headerlink" title="首先我们需要定义项目存在的事件"></a>首先我们需要定义项目存在的事件</h6><h5 id="mutation-type-js"><a href="#mutation-type-js" class="headerlink" title="mutation-type.js"></a>mutation-type.js</h5><h5 id="设置登录状态"><a href="#设置登录状态" class="headerlink" title="设置登录状态"></a>设置登录状态</h5><p>##### </p>
<pre><code>export const SET_LOGREG_SHOW = &#39;SET_LOGREG_SHOW&#39;
</code></pre><h6 id="接着在编写一个状态仓库-logreg-js"><a href="#接着在编写一个状态仓库-logreg-js" class="headerlink" title="接着在编写一个状态仓库(logreg.js)"></a>接着在编写一个状态仓库(logreg.js)</h6><pre><code>import * as types from &#39;../mutations-types&#39;(不理解import as的自行看es6模块章节)
const state ={
show: false //1:登录 2：注册 3：找回密码
}
const getters = {
getLogregShow: state=&gt; state.show
}
const mutations = {
[types.SET_ISLOGREGSHOW] (state,show){
state.show = show
}
}
const actions = {
setLogregShow({commit},show）{
commit(types.SET_ISLOGREGSHOW，show)
}
}
export default {
state,
getters,
mutations,
actions
}
</code></pre><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><blockquote>
<p> 关于上面代码一些命名(比如getters下面的getLogregShow,以及actions下面的setLogregShow,),这个命名完全看个人爱好,我觉得这样写能更好的让人理解get是获取XXX,set是设置XXX.</p>
</blockquote>
<h6 id="接下来不用我说大家应该也知道要在store中导入这个仓库-并且在根组件注册仓库才能全局使用"><a href="#接下来不用我说大家应该也知道要在store中导入这个仓库-并且在根组件注册仓库才能全局使用" class="headerlink" title="接下来不用我说大家应该也知道要在store中导入这个仓库 ,并且在根组件注册仓库才能全局使用"></a>接下来不用我说大家应该也知道要在store中导入这个仓库 ,并且在根组件注册仓库才能全局使用</h6><pre><code> import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
import logreg from &#39;./modules/logreg.js&#39;
Vue.use(Vuex)
export default new Vuex.Store({
modules:{
logreg
}
})
</code></pre><h6 id="然后你的三个组件都写好了-那么接下来就要控制渲染哪个组件了"><a href="#然后你的三个组件都写好了-那么接下来就要控制渲染哪个组件了" class="headerlink" title="然后你的三个组件都写好了 那么接下来就要控制渲染哪个组件了"></a>然后你的三个组件都写好了 那么接下来就要控制渲染哪个组件了</h6><h6 id="比如你的三个组件分别为signUp-vue-signIn-vue-retrieve-vue"><a href="#比如你的三个组件分别为signUp-vue-signIn-vue-retrieve-vue" class="headerlink" title="比如你的三个组件分别为signUp.vue signIn.vue retrieve.vue"></a>比如你的三个组件分别为signUp.vue signIn.vue retrieve.vue</h6><h6 id="既然是渲染那么我们知道可以用v-if-自行看v-if与v-show的区别"><a href="#既然是渲染那么我们知道可以用v-if-自行看v-if与v-show的区别" class="headerlink" title="既然是渲染那么我们知道可以用v-if 自行看v-if与v-show的区别"></a>既然是渲染那么我们知道可以用v-if 自行看v-if与v-show的区别</h6><h6 id="我们可以做一个新的组件就叫做signComp-vue-是这三个组件的父组件"><a href="#我们可以做一个新的组件就叫做signComp-vue-是这三个组件的父组件" class="headerlink" title="我们可以做一个新的组件就叫做signComp.vue 是这三个组件的父组件"></a>我们可以做一个新的组件就叫做signComp.vue 是这三个组件的父组件</h6><pre><code>&lt;template&gt;
&lt;div&gt;
&lt;sign-in v-if=&quot;show===1&quot;&gt;&lt;/sign-in&gt;
&lt;sign-up  v-else-if=&quot;show===2&quot;&gt;&lt;/sign-up&gt;
&lt;retrieve v-else-if=&quot;show===3&quot;&gt;&lt;/retrieve&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import signIn from 
import signUp from 
import retrieve from 
components:{
signIn,signUp,retrieve
}
&lt;/script&gt;
</code></pre><h6 id="这样你在其他调用的时候只需要两部-映射方法-调用方法"><a href="#这样你在其他调用的时候只需要两部-映射方法-调用方法" class="headerlink" title="这样你在其他调用的时候只需要两部  映射方法 调用方法"></a>这样你在其他调用的时候只需要两部  映射方法 调用方法</h6><h6 id="第一："><a href="#第一：" class="headerlink" title="第一："></a>第一：</h6><pre><code>mapActions({
showLogreg:&#39;setLogregShow&#39;
})
</code></pre><p>比如点击了登录<br>那么 可以用</p>
<pre><code>this.showLogreg(1)
</code></pre><p>就会弹出你的登录组件</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><blockquote>
<p>新组建里面的show 也是通过getters映射到当前组件的</p>
</blockquote>
<pre><code> computed: {
    ...mapGetters({
      show: &#39;getLogregShow&#39;
    })
},
</code></pre><h3 id="为什么会弹出呢-很简单-流程如下"><a href="#为什么会弹出呢-很简单-流程如下" class="headerlink" title="为什么会弹出呢  很简单 流程如下"></a>为什么会弹出呢  很简单 流程如下</h3><h6 id="调用showLogreg-1-》找到对应仓库的方法，找到setLogregShow-gt-由于调用的时候传入了1-那么就相当于提交到mutations一个新的状态值-mutations收到这个提交会做一件事情-会把state下面对应的数据改变-（把show变为1）"><a href="#调用showLogreg-1-》找到对应仓库的方法，找到setLogregShow-gt-由于调用的时候传入了1-那么就相当于提交到mutations一个新的状态值-mutations收到这个提交会做一件事情-会把state下面对应的数据改变-（把show变为1）" class="headerlink" title="调用showLogreg(1)=========》找到对应仓库的方法，找到setLogregShow() ====&gt;由于调用的时候传入了1 那么就相当于提交到mutations一个新的状态值, mutations收到这个提交会做一件事情 会把state下面对应的数据改变 （把show变为1）"></a>调用showLogreg(1)=========》找到对应仓库的方法，找到setLogregShow() ====&gt;由于调用的时候传入了1 那么就相当于提交到mutations一个新的状态值, mutations收到这个提交会做一件事情 会把state下面对应的数据改变 （把show变为1）</h6><h6 id="当show为1的时候-这个组件就会被渲染"><a href="#当show为1的时候-这个组件就会被渲染" class="headerlink" title="当show为1的时候  这个组件就会被渲染"></a>当show为1的时候 <sign-in v-if="show===1"></sign-in> 这个组件就会被渲染</h6><h6 id="那么用户就看到了登录组件"><a href="#那么用户就看到了登录组件" class="headerlink" title="那么用户就看到了登录组件"></a>那么用户就看到了登录组件</h6>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://static.soyoung.com/sy-pre/logo-1560924611786.png" alt="端端">
            
              <p class="site-author-name" itemprop="name">端端</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/lifenglei" title="GitHub &rarr; https://github.com/lifenglei"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/1125911451" title="QQ &rarr; 1125911451"><i class="fa fa-fw fa-skype"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">端端</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>



  
  



  
  



  
  







  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>

  
  <script src="/lib/three/canvas_lines.min.js"></script>

  
  <script src="/lib/three/canvas_sphere.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      const selection = document.getSelection();
      const selected = selection.rangeCount > 0 ? selection.getRangeAt(0) : false;
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('Copied');
        else $(this).text('Copy failed');
      
      ta.blur(); // For iOS
      $(this).blur();
      if (selected) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('Copy');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
