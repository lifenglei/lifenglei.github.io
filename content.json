{"meta":{"title":"前端开发沉淀","subtitle":null,"description":null,"author":"端端","url":"https://github.com/lifenglei"},"pages":[],"posts":[{"title":"ts章之基础类型","slug":"ts章之基础类型","date":"2019-06-20T03:54:41.000Z","updated":"2019-06-20T03:56:15.388Z","comments":true,"path":"2019/06/20/ts章之基础类型/","link":"","permalink":"https://github.com/lifenglei/2019/06/20/ts章之基础类型/","excerpt":"","text":"基础类型介绍为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。布尔值let isDuan: boolean = false 数字和javascript一样，ts里的所有数字都是浮点数，这些浮点数的类型是number。除了支持十进制和十六进制字面量，ts还支持es5中引入的二进制和八进制字面量。let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 字符串普通字符串let name:string = &quot;duanduan&quot; name = &quot;lei&quot; 模板字符串let name: string = &quot;duanduan&quot; let age: number = 29; let sentence: string = `Hello,my name is ${name}.I will be ${age+1} years old next month` 数组 可以在元素类型后面接上[],表示由此类型元素组成的U一个数组let list: number[] = [1,2,3]; 数组泛型，Array&lt;元素类型&gt; let list: Array&lt;number&gt; = [1,2,3] 元祖类型 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。//declare a tuple typelet x: [string,number];//Initialize itx = [‘duanduan’,29] // ok//Initialize it incorrectlyx = [10,’duanduan’] // Error 当访问一个已知索引的元素 会得到正确的类型console.log(x[0].substr(1)) //okconsole.log(x[1].substr(1))// ‘number’ does not have ‘substr’当访问一个越界的元素 会使用联合类型替代 x[3] = ‘world’; // OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, ‘string’ 和 ‘number’ 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 联合类型是高级主题，我们会在以后的章节里讨论它。枚举enum类型是对JavaScript标准数据类型的一个补充。enum Info {name=’duanduan’,website=’blog’,age=29}let n: Info = Info.name 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：enum Color {Red = 1, Green, Blue}let colorName: string = Color[2]; console.log(colorName); // 显示’Green’因为上面代码里它的值是2 Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：let notSure: any = 4;notSure = “maybe a string instead”;notSure = false; // okay, definitely a boolean 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：let list: any[] = [1, true, “free”];list[1] = 100; Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：function warnUser(): void { console.log(&quot;This is my warning message&quot;); } Null 和 UndefinedTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。Nevernever类型表示的是那些永不存在的值的类型// 返回never的函数必须存在无法达到的终点function error(message: string): never { throw new Error(message); } // 推断的返回值类型为neverfunction fail() { return error(&quot;Something failed&quot;); } // 返回never的函数必须存在无法达到的终点function infiniteLoop(): never { while (true) { } } Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。例如：declare function create(o: object | null): void; create({ prop: 0 }); // OKcreate(null); // OK create(42); // Errorcreate(“string”); // Errorcreate(false); // Errorcreate(undefined); // Error 类型断言 尖括号 let someValue: any = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; as语法 let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; 总结TypeScript中的数据类型有：Undefined :Number:数值类型;string : 字符串类型;Boolean: 布尔类型；enum：枚举类型；any : 任意类型，一个牛X的类型；void：空类型；Array : 数组类型;Tuple : 元祖类型；Null ：空类型 附上我在学习ts的时候写的测试代码`ts //数组声明let arr1:number[] //声明数值类型的数组let arr2:Array//声明字符串类型的数组 //字面量赋值let arr3:number[] = []let arr4:number[] = [1,2,3,4]let arr5:Array=[‘1’,’3’,’6’]let someValue:string=’this is a boy’let strLength:number = (someValue).length// console.log(strLength)let arr6:Array=[true,false,true]//元祖类型let x:[string,number]x=[‘1’,2]//引用类型字符串let like:String = new String(‘code’)// console.log(like)//引用类型日期对象let d:Date = new Date()//传递一个整数let da:Date = new Date(1000)console.log(da)//传递一个字符串//yyyy/MM/dd hh:mm:ss，yyyy-MM-dd hh:mm:ss，yyyy-MM-ddThh:mm:sslet dt:Date = new Date(‘2018/09/06 05:30:00’)// console.log(dt)//正则表达式 let reg1:RegExp = new RegExp(‘code’)let reg2:RegExp = new RegExp(‘code’,’gi’)let reg3:RegExp = /code/let reg4:RegExp = /code/gilet site:string = ‘codeview.com’let isT:boolean = reg3.test(site)// console.log(isT)console.log(reg4.exec(site))` ^^下一节 ts章之接口","categories":[],"tags":[]},{"title":"canvas海报","slug":"canvas海报","date":"2019-06-19T07:28:35.000Z","updated":"2019-06-19T07:28:43.080Z","comments":true,"path":"2019/06/19/canvas海报/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/canvas海报/","excerpt":"","text":"分享到朋友圈海报生成实现临时接到一个需求需要实现一个分享到朋友圈的功能 用户点击分享到朋友圈按钮后要生成海报图 方便用户保存分享 刚接到这个需求的时候是一脸懵逼 接着是三脸懵逼 在技术群里咨询 然而并没有找到答案 思考一番后我决定使用canvas去实现 然而我认识canvas canvas却不认识我 只好当天晚上看canvas的api 隔天完成了这个需求 下面分享下绘制的过程 也是自己的一个总结一：canvas有哪些功能1.绘制图形 2.绘制图像 3.绘制文字 二：canvas的绘制步骤canvas就是画图 那么到底该怎么画图呢 首先大家要明白canvas 2D环境坐标系 下面以一张简单的图来说明一下(注：该图来自为w3cPlus)相信学过坐标系系统的同学都能明白这张图的意思 其实canvas就是在正确的位置用正确的api绘制出自己想要的图 正确的位置就是需要坐标来体现的 设计稿呈现 代码部分 要想学好canvas对着代码看一句 然后就翻看canvas的api import wepy from &#39;wepy&#39; let app = getApp() export default class tczan extends wepy.component { props = { ob:{ type:Object, default:{ //头像路径 } } } methods = { saveImageToPhotosAlbum(){ this.savePhoto() } } //文字换行 canvasWrapText(text,cs,x, y, maxWidth, lineHeight){ // 字符分隔为数组 var arrText = text.split(&#39;&#39;); var line = &#39;&#39;; for (var n = 0; n &lt; arrText.length; n++) { var testLine = line + arrText[n]; var metrics = cs.measureText(testLine); var testWidth = metrics.width; if (testWidth &gt; maxWidth &amp;&amp; n &gt; 0) { cs.fillText(line, x, y); line = arrText[n]; y += lineHeight; } else { line = testLine; } } cs.fillText(line, x, y); } onLoad(options){ wx.downloadFile({ url: this.ob.avatarUrl }) this.imageToPhotosAlbum() } savePhoto(){ wx.showLoading({ title:&#39;保存中...&#39; }) var that = this; var unit = that.ob.screenWidth/375 wx.canvasToTempFilePath({ x: 0, y: 0, width: unit * 375, height: unit * 462.5, destWidth: unit * 375, destHeight: unit * 462.5, canvasId: &#39;share&#39;, success: function (res) { that.ob.shareImgPath=res.tempFilePath if (!res.tempFilePath) { wx.showModal({ title: &#39;提示&#39;, content: &#39;图片绘制中，请稍后重试&#39;, showCancel: false }) } //画板路径保存成功后，调用方法吧图片保存到用户相册 wx.saveImageToPhotosAlbum({ filePath: res.tempFilePath, //保存成功失败之后，都要隐藏画板，否则影响界面显示。 success: (res) =&gt; { wx.showToast({ title: &#39;保存完成&#39;, //标题 icon: &#39;success&#39;, //图标，支持&quot;success&quot;、&quot;loading&quot; duration: 2000 //提示的延迟时间，单位毫秒，默认：1500 }) that.ob.canvasHidden=true }, fail: (err) =&gt; { wx.showToast({ title: &#39;保存失败&#39;, //标题 icon: &#39;&#39;, //图标，支持&quot;success&quot;、&quot;loading&quot; duration: 2000, //提示的延迟时间，单位毫秒，默认：1500 mask: false //是否显示透明蒙层，防止触摸穿透，默认：false }) that.ob.canvasHidden=true } }) } }) } imageToPhotosAlbum(){ wx.showLoading({ title:&#39;生成中...&#39; }) var that = this; that.canvasHidden = false var unit = that.ob.screenWidth/375 var {avatarurl,cover,nickName,type,poi,description,title}=that.ob var context = wx.createCanvasContext(&#39;share&#39;) var description = that.ob.description var wxappName = &quot;打开小程序马上浏览&quot; var gradient = context.createLinearGradient(0, 0, unit * 50, 0); //绘制渐变部分 gradient.addColorStop(0,&quot;#F3EED1&quot;); gradient.addColorStop(1,&quot;#EDE5B7&quot;); context.fillStyle=gradient; context.fillRect(-unit*20,unit*10,unit *85,unit *50); var gradients = context.createLinearGradient(0, 0, unit * 50, 0); //绘制渐变部分 gradients.addColorStop(0,&quot;#F3EED1&quot;); gradients.addColorStop(1,&quot;#fff&quot;); context.fillStyle=gradients; context.fillRect(-unit*40,unit*90,unit *100,unit *50); context.drawImage(`${cover}`, unit * 140, unit * 455, unit * 64, unit * 64) context.drawImage(`${cover}`, unit * 40, unit * 175, unit * 255, unit * 150) //绘制文本 context.font=&quot;bold 12px PingFangSC-Medium&quot;; context.setFillStyle(&#39;#666&#39;) context.fillText(`${nickName}`, unit * 90, unit * 30) //绘制文字 context.font=&quot;12px PingFangSC-Light&quot;; context.setFillStyle(&#39;#999&#39;) context.fillText(`推荐了1篇${type}`, unit * 90, unit * 53) //绘制文字 context.fillText(`${poi}`, unit * 40, unit * 160) //绘制文字 context.fillText(wxappName, unit * 115, unit * 580) context.setFontSize(14) context.setFillStyle(&quot;#999&quot;) context.fillText(&quot;长按识别小程序&quot;, unit * 115, unit * 560) //绘制文字 that.canvasWrapText(`${description}`,context, unit * 40, unit * 355,unit * 255,unit * 24) context.font=&quot;24px PingFangSC-Medium&quot;; context.setFillStyle(&#39;#444&#39;) that.canvasWrapText(`${title}`,context, unit * 40, unit * 129,unit * 225,unit * 24) //圆形裁剪填充头像 context.save() context.beginPath() context.lineWidth = unit *8; context.strokeStyle = &quot;#fff&quot;;//线条的颜色 context.lineCap = &quot;round&quot;; context.arc(unit * 59, unit * 36, unit *22, 0, 2 * Math.PI,true) context.stroke(); context.closePath(); context.clip() context.drawImage(`${cover}`, unit * 33, unit *10, unit * 50, unit * 50) context.restore() wx.hideLoading() context.draw(false, function () { }); } } 设计稿还原 （部分字段没有 设计变更 图中不展示） 还原能力有限 目前还在进行细节调整 但是已经具备雏形 从懵逼到理解 到完成需求 我觉得也是一种进步吧canvas的api很多 重在理解和自己动手操作 可以看看w3c上的教程","categories":[],"tags":[]},{"title":"vueConf总结","slug":"vueConf总结","date":"2019-06-19T07:23:26.000Z","updated":"2019-06-19T07:23:43.499Z","comments":true,"path":"2019/06/19/vueConf总结/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/vueConf总结/","excerpt":"","text":"vueConf 2019 尤雨溪演讲总结 距离参加 VueConf第一届大会已经很久了，yubo的介绍一如既往的有意思❤️，是他的努力保持了大会热情的社区氛围！另一个彩蛋就是Evan You 带了自己的亲人和孩子来到现场，真的是其乐融融！ 尤雨溪@State of vue 发展现状#####Chrome DevTools 有约 90 万的周活用户，React 相比有 160 万。Evan 推荐用 Chrome DevTools 来预测 Vue 的项目的真实开发者数据。Vue 有全球化的影响力，在非常多的国家有相应的活动，可以 通过 events.vuejs.org 查找。State of JavaScript 2018 年统计说明在前端框架的满意度是第一名（91%），并在 Stack Overflow 的数据里体现是第二受欢迎的前端框架。 团队####现在 Vue 有 20 人活跃的开发者，大部分日常工作与Vue 相关，完全独立运营，而成本主要来自于赞助商，年来稳步增长。蒋豪群（@sodatea）全职在维护CLI及相关工具链。 进展 ####自 2018 年年底有过预告 Vue.js 3.0 的设定目标，其实在今年年初的时候大部分功能已经实现。但同时，在开发的同是也在研究业界最新的方案，Vue 在 3.0 使用了 Proxy 的功能，但是 IE 11 仍然无法支持却有一定市场占有率。 更快 #####1.Object.defineProperty -&gt; Proxy：Proxy 不需要对原始对象做太多改动，效率更高 2.Virtual DOM 重构：组建的启动速度等比 2.5 快了一倍，生成 VNode 参数一致化。但是还是可以做的更好，Virtual DOM 的目的并非只是速度，其核心价值在于用 JavaScript 表达 DOM 状态，因此它本身其实是有成本的。即每次更新时， vdom 树需要每次都重新建立，因此传统的 vdom 是有性能瓶颈。而这背后的原因是 vdom 最早是由 JSX 写的表达逻辑（灵活性），而非是模版语言，因此不能通过模版内容推测一些信息。 3.如何最大化的动静结合？即兼容 render function 的灵活性，及模版表达的信息将一个逻辑内部、外部的节点分开，每个动态节点当成一个 (fragment) 这使得动态节点别话只会出现在如 v-if、v-for 这样的结构性指令之下。将节点关系切分为一个一个的区块树（Block Tree，梗😊），减少无谓的遍历。 这使得vdom 的更新性能与模版大小相关 =&gt; 与动态内容的数量相关（即哪儿需要改，就只让哪儿改，只实现最小操作）速度优化：2.6.10（36ms），3.0（5.44ms）约 6 倍的速度增长 TypeScript Class API ❌： 原本的目的是支持 TypeScript：this 下的属性类型推到无法有效实现，Decorator 提案很不稳定 Class API 除了使用了原生愈发，并未带来任何新的优势，OOP 里的继承等价值在 UI 层使用较少 Function-based API ✅： 更好的 TypeScript 类型推导支持（不需要任何手动的类型声明，一套代码同时支持），更灵活的逻辑复用（没有命名冲突、props 等数据来源更清晰、没有额外的创建成本），Tree-shaking 友好，代码可以被压缩逻辑复用案例：鼠标位置监听mixins 当大量使用时候 ❌ 命名空间冲突 ❌ 模板数据来源不清晰高阶组件 当高阶组件大量使用时候 ❌ props命名空间冲突 ❌ props来源不清晰 ❌ 额外的组件实例性能消耗 Renderless Components 作用域插槽 当使用作用域插槽时候 ✅ 没有命名空间冲突 ✅ 数据来源清晰 ❌ 额外的组件实例性能消耗with New API 当使用新的api时候 ✅ 没有命名空间冲突 ✅ 数据来源清晰 ✅ 没有额外的组件实例性能消耗 对比React Hooks 同样的逻辑组合、复用能力 只调用一次 符合js直觉 没有闭包变量问题 没有内存/GC压力 不存在内联回调导致子组件无法永远更新 更多RFC详情 Q&amp;A1.Vue.js 3.0 还有哪些不足？ IE 11 还是会支持，只是会额外花时间来解决。此外，3.0 的劣势都在尽力解决 3.0 是否有破坏性的改动？升级效率？这就是 RFC 的价值，所有的重大改变、背后的意义、如何应对这些修改。基本的修改都会有自动化工具来更新。同时会有一个兼容版本，降低更新成本。 React 渲染切片，Vue 仍会有相关成本？切片并非是万能药，只有极端条件下可以完成性能的保障。内部的复杂度较高，实现后仍未能满足性能效果，切片会让 nextTick 等代码都有破坏性修改（因为可能是多个 nextTick。 Vue 未来的发展方向？门槛低，价值高。只要有人用，就一直维护和更新 很多企业用户在用 React，因为在 Native 方向有更好的兼容，Vue 未来会对 Native 有更好的兼容吗？一套代码，多端实现。React 虽然有 React Native，但是各个厂家都有相应的对策，Google 有Flutter、Apple 有 SwiftUI，大家不可能让一个开发范式被一个公司使用。恰好，Vue 是独立的开源，没有企业竞争。 END","categories":[],"tags":[]},{"title":"自定义指令","slug":"自定义指令","date":"2019-06-19T07:22:52.000Z","updated":"2019-06-19T08:46:28.861Z","comments":true,"path":"2019/06/19/自定义指令/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/自定义指令/","excerpt":"","text":"自定义指令directive,混合mixins一.自定义指令directive 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。来个实例，当页面加载时，该input元素将获得焦点： 注册一个全局自定义指令 v-focusVue.directive(&#39;focus&#39;, { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 如果想注册局部指令，组件中也接受一个 directives 的选项：directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：&lt;input v-focus&gt; 钩子函数 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。钩子函数参数 指令钩子函数会被传入以下参数： el:指令所绑定的元素，可以用来直接操作 DOM 。 binding:一个对象，包含以下属性: name:指令名，不包括 v- 前缀。 value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue:指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg: 传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers:一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 这是一个使用了这些属性的自定义钩子样例： Vue.directive(&#39;demo&#39;, { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = &#39;name: &#39; + s(binding.name) + &#39;&lt;br&gt;&#39; + &#39;value: &#39; + s(binding.value) + &#39;&lt;br&gt;&#39; + &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; + &#39;argument: &#39; + s(binding.arg) + &#39;&lt;br&gt;&#39; + &#39;modifiers: &#39; + s(binding.modifiers) + &#39;&lt;br&gt;&#39; + &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;) } }) new Vue({ el: &#39;#hook-arguments-example&#39;, data: { message: &#39;hello!&#39; } }) 结果： name: &quot;demo&quot; value: &quot;hello!&quot; expression: &quot;message&quot; argument: &quot;foo&quot; modifiers: {&quot;a&quot;:true,&quot;b&quot;:true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 在很多时候，你可能想在 bind 和update时触发相同行为，而不关心其它的钩子。比如这样写: Vue.directive(‘color-swatch’, function (el, binding) { el.style.backgroundColor = binding.value }) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。&lt;div v-demo=&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;&gt;&lt;/div&gt; Vue.directive(&#39;demo&#39;, function (el, binding) { console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot; }) 混合mixins混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。 // 定义一个混合对象 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log(&#39;hello from mixin!&#39;) } } } // 定义一个使用混合对象的组件 var Component = Vue.extend({ mixins: [myMixin] }) var component = new Component() // =&gt; &quot;hello from mixin!&quot; 选项合并 当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ： var mixin = { created: function () { console.log(&#39;混合对象的钩子被调用&#39;) } } new Vue({ mixins: [mixin], created: function () { console.log(&#39;组件钩子被调用&#39;) } }) // =&gt; &quot;混合对象的钩子被调用&quot; // =&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { methods: { foo: function () { console.log(&#39;foo&#39;) }, conflicting: function () { console.log(&#39;from mixin&#39;) } } } var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log(&#39;bar&#39;) }, conflicting: function () { console.log(&#39;from self&#39;) } } }) vm.foo() // =&gt; &quot;foo&quot; vm.bar() // =&gt; &quot;bar&quot; vm.conflicting() // =&gt; &quot;from self&quot; 注意：Vue.extend() 也使用同样的策略进行合并。 全局混合 也可以全局注册混合对象。注意使用！ 一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。 Vue.mixin({ created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: &#39;hello!&#39; }) // =&gt; &quot;hello!&quot; 谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用 自定义选项合并策略 自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数：Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) { // return mergedVal } 对于大多数对象选项，可以使用 methods 的合并策略：var strategies = Vue.config.optionMergeStrategies strategies.myOption = strategies.methods 结束^^","categories":[],"tags":[]},{"title":"vue插件开发","slug":"vue插件开发","date":"2019-06-19T07:22:21.000Z","updated":"2019-06-19T07:22:34.147Z","comments":true,"path":"2019/06/19/vue插件开发/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/vue插件开发/","excerpt":"","text":"如何去写Vue插件目的实现一个简单的提示插件实现官方文档介绍插件通常会为Vue提供全局功能。插件的范围没有限制—-一般有以下 添加全局方法或者属性，如: vue-custom-element 添加全局资源：指令/过滤器/过渡等，如 vue-touch 通过全局 mixin 方法添加一些组件选项，如: vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router 官网给出的代码框架如下 Myplugin.install=function(Vue,options){ //添加全局方法或者属性 Vue.myGlobalMethods = function(){ ....逻辑 } } //添加全局指令 Vue.directive(&#39;my-directive&#39;,{ bind(el,binding,vnode,oldVnode){ // ...逻辑 } ... }) //注入组件 Vue.mixin({ created:function(){ ...//逻辑 } }) 添加实例方法 Vue.prototype.$myMethod=function(methodOptions){ ...逻辑 } 下面展示一个提示插件 1.编写组件toast.vue &lt;template&gt; &lt;div class=&quot;m-toast&quot; :class=&quot;{opacity}&quot; v-show=&quot;visible&quot;&gt;&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { opacity: false, visible: false, timer: null, html: &#39;&#39; } }, mounted () { }, methods: { /* * html 显示的html片段 * cb 隐藏之后的回调函数 * time 自动隐藏时间，-1为不进行隐藏 * */ show (html, cb, time) { this.html = html this.visible = true this.$nextTick(() =&gt; { this.opacity = true }) window.clearTimeout(this.timer) this.timer = window.setTimeout(() =&gt; { this.opacity = false setTimeout(() =&gt; { this.visible = false }, 500) cb &amp;&amp; cb() }, time || 3000) }, hide () { this.opacity = false setTimeout(() =&gt; { this.visible = false }, 500) } } } &lt;/script&gt; &lt;style lang=&quot;less&quot;&gt; .m-toast { display: flex; justify-content: center; align-items: center; position: fixed; width: 100%; left: 0; top: 40%; z-index: 99999; transition: opacity .5s; opacity: 0; &amp;.opacity{ opacity: 1; } p { position: relative; display: inline-block; background: rgba(252,93,123,.5); padding: 2% 4%; min-width: 20%; text-align: center; color: #FFF; line-height: 1.2; border-radius: .2rem; font-size: .28rem; max-width: 60%; line-height: .4rem; } } &lt;/style&gt; 2.插件需要有install方法toast.js import Toast from &#39;./index&#39; export default { install (Vue, options = {}) { const VueToast = Vue.extend(Toast) let toast = null function $toast (html, cb, time) { return new Promise(resolve =&gt; { if (!toast) { toast = new VueToast() toast.$mount() document.querySelector(options.container || &#39;body&#39;).appendChild(toast.$el) } toast.show(html, cb, time) resolve() }) } Vue.prototype.$toast = $toast } } 全局使用 this.$toast(&#39;今日输送能量任务已完成明天再来吧~&#39;)","categories":[],"tags":[]},{"title":"sync使用","slug":"sync使用","date":"2019-06-19T07:21:41.000Z","updated":"2019-06-19T08:44:14.577Z","comments":true,"path":"2019/06/19/sync使用/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/sync使用/","excerpt":"","text":"Sync的使用 在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync 修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。 在2.0发布一段之后，无论在业务组件还是在功能组件库上面的，大量的子组件改变父子组件的数据和组件库中可能达到大功率的复用，但是在2.3中回归，重新引入了 .sync 修饰符，这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。之前的例子中，v-model 毕竟不是给组件与组件之间通信而设计的双向绑定，无论从语意上和代码写法上都没有 .sync 直观和方便。无论从 v-model 还是 .sync 修饰符来看，都离不开 $emit v-on 语法糖的封装，主要目的还是为了保证数据的正确单向流动与显示流动。 &lt;demo :foo.sync=&quot;something&quot;&gt;&lt;/demo&gt; 语法糖的扩展&lt;demo :foo=&quot;something&quot; @update:foo=&quot;val =&gt; something = val&quot;&gt;&lt;/demo&gt; 解析 foo 则是 demo 子组件需要从父组件 props 接收的数据 通过事件显示监听 update:foo (foo则是 props 显示监听的数据)，通过箭头函数执行回调，把参数传给 something，则就形成了一种双向绑定的循环链条 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：this.$emit(‘update:foo’, newValue)同时父组件@update:foo也是依赖于子组件的显示触发，这样就可以很轻松的捕捉到了数据的正确的流动。第一个参数则是 update 显示更新的事件，跟在后面的：foo则是需要改变对应的props值。第二个参数传入的是你希望父组件foo数据里将要变化的值，以用于父组件接收update时更新数据。 子组件&lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;show&#39;], methods: { closeModel () { this.$emit(&#39;update:show&#39;,false) } } } &lt;/script&gt; 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo :show.sync=&quot;show&quot; &gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 上面的 case 同样也解决了 model 显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了 v-model 做不了的事，基于 props 的原子化，对传入的 props 进行多个数据双向绑定.sync 也能轻松做到。父组件 &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo :show.sync=&quot;show&quot; :msg.sync=&quot;msg&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false, msg: &#39;这是一个model&#39; } } } &lt;/script&gt; 子组件&lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;p&gt;{{msg}}&lt;/p&gt; &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;button @click=&quot;$emit(&#39;update:msg&#39;,&#39;改变了model文案&#39;)&quot;&gt;改变文案&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;show&#39;, &#39;msg&#39;], methods: { closeModel () { this.$emit(&#39;update:show&#39;,false) } } } &lt;/script&gt; warn 子组件改变父组件的数据时，update 冒号后面的参数和父组件传递进来的值是同步的，想改变那个，则冒号后面的值对应的那个，两者是一一对应的，同时也是必填的。同样还可以在组件 template 里点击执行 click 后不但可以支持回调函数，还可以写入表达式，只是一种直观的表现还是推荐这种写法的。.sync 修饰符给我们开发中带来了很大的方便，同时在2.0的初期的组件库中大量的 v-model 给开发者用起来还是很别扭，在.sync 回归后同时也会慢慢向.sync 进行一个版本的迁移。 END— 下一次分享$attrs $listeners使用","categories":[],"tags":[]},{"title":"$attr使用","slug":"��使用","date":"2019-06-19T07:20:23.000Z","updated":"2019-06-19T08:35:19.148Z","comments":true,"path":"2019/06/19/��使用/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/��使用/","excerpt":"","text":"$attrs与$listenrs使用 2.4.0 新增 类型：{ [key: string]: string } 只读 详细: 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。官方说法似乎有点模糊 其实可以这么去理解因为在项目中深层次组件交互的话可能就需要 Vuex 助力了，但是如果只是一个简单的深层次数据传递， 或者进行某种交互时需要向上通知顶层或父层组件数据改变时，大材小用Vuex可能未免有点多余！ $attr 与 interitAttrs 之间的关系interitAttrs： 2.4.0 新增 类型：boolean 默认值：true 详细: 默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。warn：这个选项不影响 class 和 style 绑定。下面通过简单demo解释下父组件 &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;demo :count=&quot;count&quot; :num=&quot;num&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { count: &#39;count message&#39;, num: &#39;num message&#39; } }, } &lt;/script&gt; 子组件 &lt;template&gt; &lt;div&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;count&#39;] } &lt;/script&gt; 父组件在子组件中进行传递 count 和num 两个数据，在子组件中，应该有相对应的 props 定义的接收点，如果在 props 中定义了，你会发现无论是 count 和 num 都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。虽然在父组件中在子组件模版上通过 props 定义了两个数据，但是子组件中的 props 只接收了一个，只接收了 count，并没有接收 num，没有进行接收的此时就会成为子组件根无素的属性节点。 interitAttrs = false 发生了什么 ？子组件 &lt;template&gt; &lt;div&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, props: [&#39;count&#39;], interitAttrs:false } &lt;/script&gt; 对子组件进行一个改动，我们加上 inheritAttrs: false，从字面上的翻译的意思，取消继承的属性，然而 props 里仍然没有接收 num，发现就算 props 里没有接收 num，在子组件的根元素上并没有绑定任何属性。 $attrs 在前面的例子中，子组件props中并没有接受num，设置选项 inheritAttrs： false，同样也不会作为根元素的属性节点，整个没有接收的数据都被 $attr 实例属性给接收，里面包含着所有父组件传入而子组件并没有在 Props里显示接收的数据。 为了验证事实，可以在子组件中加上 created () { console.log(this.$attrs) } 打印出来则是一个对象 {num: “num message”} warn想要通 $attr 接收，但必须要保证设置选项 inheritAttrs: false，不然会默认变成根元素的属性节点。开头说了，最有用的情况则是在深层次组件运用的时候，创建第三层孙子组件，作为第二层父组件的子组件，在子组件引入的孙子组件，在模版上把整个 $attr 当数作数据传递下去，中间则并不用通过任何方法去手动转换数据。子组件 &lt;template&gt; &lt;div&gt; &lt;next-demo v-bind=&quot;$attrs&quot;&gt;&lt;/next-demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import nextDemo from &#39;./nextdemo.vue&#39; export default { name: &#39;demo&#39;, components: { nextDemo }, created () { console.log(this.$attrs) } } &lt;/script&gt; 孙子组件 &lt;template&gt; &lt;div&gt; {{count}}{{num}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props : [ &#39;count&#39; , &#39;num&#39;] } &lt;/script&gt; 孙子组件在 props 接收子组件中通过 $attrs 包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了$attrs进行了统一接收，再往下传递，最后通过孙子组件进行接收。以此类推孙子组件仍然不想接收，再传入下级组件，我们仍然需要对孙子组件实力选项进行设置选项 inheritAttrs: false，否则仍然会成为孙子组件根元素的属性节点。 从而利用 $attrs 来接收 props 为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。$listeners 2.4.0 新增 类型：{ [key: string]: Function | Array } 只读 详细: 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 $listeners 和 $attrs 两者表面层都是一个意思，$attrs 是向下传递数据，$listeners 是向下传递方法，通过手动去调用 $listeners 对象里的方法，原理就是 $emit 监听事件，$listeners 也可以看成一个包裹监听事件的一个对象。 父组件 ``` js &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; {{firstMsg}} &lt;demo v-on:changeData=&quot;changeData&quot; v-on:another = &#39;another&#39;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { firstMsg: &#39;父组件&#39;, } }, methods: { changeData (params) { this.firstMsg = params }, another () { alert(2) } } } &lt;/script&gt; ``` 子组件 ```js &lt;template&gt; &lt;div&gt; &lt;p @click=&quot;$emit(&#39;another&#39;)&quot;&gt;子组件&lt;/p&gt; &lt;next-demo v-on=&#39;$listeners&#39;&gt;&lt;/next-demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import NextDemo from &#39;./nextdemo.vue&#39; export default { name: &#39;demo&#39;, components: { NextDemo }, created () { console.log(this.$listeners) }, } &lt;/script&gt; ``` 孙子组件 ```js &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p @click=&#39;$listeners.changeData(&quot;change&quot;)&#39;&gt;孙子组件&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;demo&#39;, created () { console.log(this.$listeners) }, } &lt;/script&gt; ``` 依然能拿到从子组中传递过来的$listeners所有的监听事件，此时并不是通过$emit去触发，而是像调用函数一样，$emit只是针对于父子组件的双向通信，$listeners包了一个对象，分别是 changeData 和 another，通过$listeners.changeData(‘change’)等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。通过 $attrs 和 $listeners 可以很愉快地解决深层次组件的通信问题，更加合理的组织你的代码。 END —下次分享$parent $children使用","categories":[],"tags":[]},{"title":"vModel语法糖","slug":"vModel语法糖","date":"2019-06-19T07:18:34.000Z","updated":"2019-06-19T08:32:34.163Z","comments":true,"path":"2019/06/19/vModel语法糖/","link":"","permalink":"https://github.com/lifenglei/2019/06/19/vModel语法糖/","excerpt":"","text":"v-model语法糖 什么是v-model语法糖 如何去理解这个语法糖 v-model 其实也是一个语法糖，想要理解语法糖，你首先要知道Input元素上本身有个 oninput事件，这是HTML5新增加的，类似onchange，每当输入框内容发生变化的时候，就会触发这个事件，然后把 Input 输入框中value 值再次传递给 newValue。此时 value 运用在一个 Input 元素上，用：v-bind:value=’newValue’，意义上面只是把Input 输入框中的 value 值与 newValue 作为一一对应的双向绑定，这就像一个循环操作，当再次触发 Input 事件时，input($event.target)对象中的value值会再次改变newValue。这里我们对 v-model 绑定在 Input 元素上进行语法糖上的解析。 在组件中使用的时候 它相当于&lt;custom-input&gt; v-bind:value=&quot;newValue&quot; v-on:input = &quot;newValue = argument[0]&quot; &lt;/custom-input&gt; 通过以上简写,通过自定义事件实现父子数据双向绑定v-bind:value=&#39;newValue&#39; 此时 value 是作为子组件接收的 Props 接收的只能是 value 吗？必须是，因为 v-model 是基于 Input 输入框定制的，其中value 值是为 Input 内部定制的v-on:input=&quot;newValue = arguments[0]&quot; 此时作用在组件上时，v-on 监听的语法糖也会有所改动，监听的并不是$event.target.value，而是回调函数中的第一个参数父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } 子组件&lt;template&gt; &lt;div v-show=&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;value&#39;], methods: { close () { this.$emit(&#39;input&#39;,false) } } } &lt;/script&gt; 这是一个模态框的基本雏形，可以在父组件通过 v-model 来进行 model 框和父组件之间的显示交互。通过子组件看出通过props接收了value值，当点击关闭的时候还是通过$emit事件触发input事件，然后通过传入 false 参数。 父组件隐式 v-on:input=”something = arguments[0]” 进行了监听，一但 Input 事件触发，父组件就会执行监听回调，从而做到了双向绑定。 定制组件 v-model 父组件定制组件，我们就可以重写v-model里的Props 和 event，默认情况下，一个组件的 v-model 会使用 value 属性和 input 事件，往往有些时候，value 值被占用了，或者表单的和自定义v-model的$emit(‘input’)事件发生冲突，为了避免这种冲突，可以定制组件 v-model，冲突示例。子组件&lt;template&gt; &lt;div v-show=&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt; {{value}} &lt;button @click=&quot;close&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;value&#39;], methods: { close () { this.$emit(&#39;input&#39;,false) } } } &lt;/script&gt; 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;button @click=&quot;show=true&quot;&gt;打开model&lt;/button&gt; &lt;demo v-model=&quot;show&quot;&gt;&lt;/demo&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Demo from &#39;./Demo.vue&#39; export default { name: &#39;hello&#39;, components: { Demo }, data () { return { show: false } } } &lt;/script&gt; 上面例子可以发现，在子组件中input中v-model和model显示的操作数据共同占用的 props中的（value），同样两者也共同占用了 emit(‘input’) 触发事件，Input 输入框的事件是自动出发，而 model显示消失是手动触发。 初始化的时候，Input 输入框的值的会被 value 传入的 false 值给自动加上，当改变 Input输入框的时候，因为冲突而导致报错。 定制 v-model， 通过 model 选项改变 props 和 event 的值，从而解除两者的冲突。 props代替掉原本 value 的值，可以自定义值 event代表掉原本 input 的触发事件，可以自定义触发事件 子组件 &lt;template&gt; &lt;div v-show=&quot;show&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt; {{value}} &lt;button @click=&quot;closeModel&quot;&gt;关闭model&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { model: { prop: &#39;show&#39;, event: &#39;close&#39; }, props: [&#39;show&#39;], data () { return { value: 10 } }, methods: { closeModel () { this.$emit(&#39;close&#39;,false) } } } &lt;/script&gt; 通过 model 选项的改变，把 props 从原本的value换成了show，input触发的事件换成了close，从而两者都不相互依赖，解决了冲突的问题。 有些时候通过父组件中的子组件模板中想传递value 值，也会导致同样的冲突。 在不用定制组件的情况下，以下的写法，也会同样导致冲突，导致同用一个 value。 props:[&#39;value&#39;] END— 下一次分享 sync的使用 改变数据流单向流","categories":[],"tags":[]},{"title":"如何开发一个登录注册组件","slug":"my-blog","date":"2018-08-10T09:12:13.000Z","updated":"2018-08-10T09:15:17.000Z","comments":true,"path":"2018/08/10/my-blog/","link":"","permalink":"https://github.com/lifenglei/2018/08/10/my-blog/","excerpt":"","text":"如何开发一个登录注册组件要开发某个功能我们就要去思考这个功能怎样实现最快捷最方便，下面以项目中的登录注册组件为例说明 一个功能要尽可能的去拆分比如这个登录注册组件就可以拆分成三个部分一：登录二 ：注册三：其他（example:找回密码）组件好写 这里就不在去写了 （组件就是可以重复利用的片段）这里我先梳理思路我们要写一个全局方法 可以控制哪个组件显示 类似于这样this.setLogShow(n)里面可以是Blooean 或者Number 比如登陆组件要显示 可以传入Number 1 ,注册组件为2 等下面我们来完善自己的仓库(log.js)为了能让你学到更多东西我采用手动写代码方式首先要明白下面四点第一：vue是数据驱动 数据改变会会更新视图 我们需要有一个初始状态值 state;第二： vue中的数据是加了钩子的 不管是get 或者set 都会触发钩子 getter是在显示数据之前进行的在编辑;第三：数据状态的改变只能通过Mutations 同步修改状态;第四：Actions 异步修改状态 且只能提交到Mutations;理解了上面四点我们开始构建我们的logIn仓库一下代码均按照所在公司要求编写首先我们需要定义项目存在的事件mutation-type.js设置登录状态##### export const SET_LOGREG_SHOW = &#39;SET_LOGREG_SHOW&#39; 接着在编写一个状态仓库(logreg.js)import * as types from &#39;../mutations-types&#39;(不理解import as的自行看es6模块章节) const state ={ show: false //1:登录 2：注册 3：找回密码 } const getters = { getLogregShow: state=&gt; state.show } const mutations = { [types.SET_ISLOGREGSHOW] (state,show){ state.show = show } } const actions = { setLogregShow({commit},show）{ commit(types.SET_ISLOGREGSHOW，show) } } export default { state, getters, mutations, actions } 注意 关于上面代码一些命名(比如getters下面的getLogregShow,以及actions下面的setLogregShow,),这个命名完全看个人爱好,我觉得这样写能更好的让人理解get是获取XXX,set是设置XXX. 接下来不用我说大家应该也知道要在store中导入这个仓库 ,并且在根组件注册仓库才能全局使用 import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import logreg from &#39;./modules/logreg.js&#39; Vue.use(Vuex) export default new Vuex.Store({ modules:{ logreg } }) 然后你的三个组件都写好了 那么接下来就要控制渲染哪个组件了比如你的三个组件分别为signUp.vue signIn.vue retrieve.vue既然是渲染那么我们知道可以用v-if 自行看v-if与v-show的区别我们可以做一个新的组件就叫做signComp.vue 是这三个组件的父组件&lt;template&gt; &lt;div&gt; &lt;sign-in v-if=&quot;show===1&quot;&gt;&lt;/sign-in&gt; &lt;sign-up v-else-if=&quot;show===2&quot;&gt;&lt;/sign-up&gt; &lt;retrieve v-else-if=&quot;show===3&quot;&gt;&lt;/retrieve&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import signIn from import signUp from import retrieve from components:{ signIn,signUp,retrieve } &lt;/script&gt; 这样你在其他调用的时候只需要两部 映射方法 调用方法第一：mapActions({ showLogreg:&#39;setLogregShow&#39; }) 比如点击了登录那么 可以用 this.showLogreg(1) 就会弹出你的登录组件 注意 新组建里面的show 也是通过getters映射到当前组件的 computed: { ...mapGetters({ show: &#39;getLogregShow&#39; }) }, 为什么会弹出呢 很简单 流程如下调用showLogreg(1)=========》找到对应仓库的方法，找到setLogregShow() ====&gt;由于调用的时候传入了1 那么就相当于提交到mutations一个新的状态值, mutations收到这个提交会做一件事情 会把state下面对应的数据改变 （把show变为1）当show为1的时候 这个组件就会被渲染那么用户就看到了登录组件","categories":[],"tags":[]}]}